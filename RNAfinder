#!/usr/bin/perl -w -- -*-Perl-*-

#############################################################################
#                                                                           #
#                                 RNAfinder                                 #
#                                                                           #
# DESCRIPTION:                                                              #
# Searches for RNAs in a genome. Wrapper around RNASpinner                  #
#                                                                           #
#############################################################################
#
#
#############################################################################
#                                 RNAfinder                                 #
#                                                                           #
#                          Copyright (C) 2008                               #
#                         Departement de Biochimie,                         #
#                          Universite de Montreal,                          #
#                     C.P. 6128, succursale Centre-ville,                   #
#                      Montreal, Quebec, Canada, H3C 2J7                    #
#                                                                           #
#                       Programming: Natacha Beck                           #
#                Project management: Franz Lang (OGMP)                      #
#                E-Mail information: natabeck@gmail.com                     #
#                                                                           #
#     This software is distributed under the GNU GENERAL PUBLIC LICENSE, as #
# published by the Free Software Foundation. A copy of version 2 of this    #
# license should be included in a file called COPYING. If not, write to the #
# Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.   #
#############################################################################
#
#    $Id: RNAfinder,v 1.32 2010/03/26 20:31:59 nbeck Exp $
#
#    $Log: RNAfinder,v $
#    Revision 1.32  2010/03/26 20:31:59  nbeck
#    Changed default output.
#
#    Revision 1.31  2010/02/18 15:53:43  nbeck
#    Added block for complete structure (rns) adjust coord.
#
#    Revision 1.30  2009/12/15 17:05:33  nbeck
#    Changed start and end position in particular case.
#
#    Revision 1.29  2009/12/14 18:29:11  nbeck
#    Fixed length of contigname.
#
#    Revision 1.28  2009/11/16 21:53:41  nbeck
#    Changed message in mail core.
#
#    Revision 1.27  2009/11/12 22:18:15  nbeck
#    Changed .log format.
#
#    Revision 1.26  2009/11/07 00:21:40  nbeck
#    Changed output format.
#
#    Revision 1.25  2009/10/26 21:20:30  nbeck
#    Added new output format and fixed some bugs for results selection.
#
#    Revision 1.24  2009/10/23 18:10:45  nbeck
#    Used gmail SMTP.
#
#    Revision 1.23  2009/10/22 17:53:45  nbeck
#    Fixed smtp problem.
#
#    Revision 1.22  2009/09/30 15:41:40  nbeck
#    Go back to old version of sub SendMail.
#    Removed CGI variable, and add -T option.
#
#    Revision 1.21  2009/09/22 18:36:50  nbeck
#    Changed sendMail subroutine due to some problem with machine without sendmail.
#
#    Revision 1.20  2009/09/18 20:04:03  nbeck
#    Added function for CGI.
#
#    Revision 1.19  2009/09/11 18:24:39  nbeck
#    Support for online version.
#
#    Revision 1.18  2009/09/01 20:45:29  nbeck
#    Fixed bug when empty result, fixed bug for tRNA H, some esthetic modification.
#
#    Revision 1.17  2009/08/20 21:31:25  nbeck
#    Added resume and NoSolution file.
#
#    Revision 1.16  2009/08/14 18:50:29  nbeck
#    Fixed bug with contig, cleaned data file (-d).
#    Changed nice of erpin and screen output.
#
#    Revision 1.15  2009/08/10 20:36:57  nbeck
#    Changed some messages and fixed bug with low evalue 00e+00.
#
#    Revision 1.14  2009/08/06 21:03:05  nbeck
#    Fixed conflicts in RNAfinderFileForMenu.pir MenuList.pir
#
#    Revision 1.13  2009/08/04 18:56:20  nbeck
#    Added verification for option -P.
#
#    Revision 1.12  2009/08/04 18:27:35  nbeck
#    Added search of the number of processor.
#
#    Revision 1.11  2009/07/24 22:01:09  nbeck
#    Added parallelization of erpin.
#
#    Revision 1.10  2009/07/24 21:32:24  nbeck
#    Fixed bug with option '-pc'.
#
#    Revision 1.9  2009/07/24 21:01:04  nbeck
#    Fixed bug with option '-pc'.
#
#    Revision 1.8  2009/07/23 19:36:00  nbeck
#    Added -c Option, and change Usage.
#
#    Revision 1.7  2009/07/21 15:58:17  nbeck
#    Fusion between RNASpinner and RNAfinder.
#
#    Revision 1.6  2008/12/03 15:07:42  nbeck
#    Added support for partial RNA and changed help message.
#
#    Revision 1.5  2008/12/02 15:36:54  nbeck
#    Fixed bug for Ac localisation.
#
#    Revision 1.4  2008/10/28 23:10:25  nbeck
#    Fixed bug for environment variables.
#
#    Revision 1.3  2008/10/28 22:54:24  nbeck
#    Fixed bug for environment variables.
#
#    Revision 1.2  2008/10/28 22:40:14  nbeck
#    Change environment variables.
#
#    Revision 1.1  2008/10/28 21:57:23  nbeck
#    Initial check-in.
#
# 


##########################
# Initialization section #
##########################

require 5.00;
use strict;
use Term::ANSIColor qw(:constants);
$Term::ANSIColor::AUTORESET = 1;
use PirObject qw( LinStruct RNAPredictionList RNAfinderFileForMenu AllerpinResult AnnotPairCollection);
use IO::File;
use File::Basename;
use Cwd;
use Bio::Tools::CodonTable;
use vars qw( $VERSION $RCS_VERSION );
use lib    ( "./lib" );
use POSIX qw{strftime};
use Sys::Hostname;

# Default umask
umask 027;

# Program's name and version number.
$RCS_VERSION='$Id: RNAfinder,v 1.32 2010/03/26 20:31:59 nbeck Exp $';
($VERSION) = ($RCS_VERSION =~ m#,v ([\w\.]+)#);
my ($BASENAME) = ($0 =~ /([^\/]+)$/);

# File with Menu
# Define Path for .cfg
my @CFG_PATH      = (".",($ENV{"HOME"} || ".")); # You can add other search directories here
push(@CFG_PATH,split(/:/,$ENV{"RNAFINDER_CFG_PATH"}))
    if $ENV{"RNAFINDER_CFG_PATH"};

my $DIR_CFG    = "";
foreach my $dir (@CFG_PATH) {
    next if !( -e "$dir/.RNAfinder.cfg" );
    $DIR_CFG    = $dir;
    last;
}
die "The config file '.RNAfinder.cfg' doesn't find. Check your installation for this one.\n"
    if !$DIR_CFG;
    
$ENV{"PATH"} .= ":./bin"; # add arbitrarily to make it work in the basic distribution env

# Treatment of config file.
my $MENUFILE  = "$DIR_CFG/.RNAfinder.cfg";
my $MENU_FILE = PirObject::RNAfinderFileForMenu->ImportFromTextFile($MENUFILE);
my $MENU_LIST = $MENU_FILE->get_List();
my $LIST_OF_SEARCHED = "";
&CheckModuleList();

print "$BASENAME (version $VERSION) by Natacha Beck.\n";

#########
# Usage #
#########

#How to use this script message
sub Usage {
	print <<USAGE;

    This program will search for and identify RNAs. It is a wrapper around a search tool
called 'erpin' [1], that needs to be installed on your system.

Credits:
--------
erpin:
    [1] Gautheret D, Lambert A. (2001) Direct RNA Motif Definition and Identification
        from Multiple Sequence Alignments using Secondary Structure Profiles.
        J Mol Biol. 313:1003-11 

    Erpin web site: http://tagc.univ-mrs.fr/erpin/

tRNASpinner:
    Pierre Rioux, Franz Lang, Departement de Biochimie, Universite de Montreal.
    Franz.Lang\@Umontreal.CA

PirObject library:
    Pierre Rioux, http://sourceforge.net/projects/pirobject/

This program ($BASENAME):
    Beck Natacha, Departement de Biochimie, Universite de Montreal.
    natabeck\@gmail.com

Usage:
-------------------
$BASENAME [-D] [-c genetic code] -d datafile -m model
               [-A alignedOut] [-L logOut] [-X xmlOut] [-C CustomOut] 
               [-pc pourcent] [-P nb_proc] [-l]

Input data options:
-------------------
-c               Genetic code, only use for tRNA in order to defined anticodon.
                 
-d data          File containing sequence to search, in FASTA format.
                 Warning: because of restrictions in how some subprocesses
                 (notable erpin itself) handle FASTA headers, make sure that
                 the first word of each header is unique and not too long.

-m model         Name of model you want to use. Use the file $MENUFILE 
                 to define model name, erpin arguments, model file ...
                 If you want to add or to modify some model you can make
                 a copy on your current directory and modify this one.
                 RNAfinder looking for this in the following order : current 
                 directory and directory defined by global variable 'RNAFINDER_CFG_PATH'.
                 Possibility to combine different models in this case you must
                 separate the different names by a comma as in 'rnpB,tRNA'.
                 
Output report options:
----------------------
5 different reports can be created by this program, you can ask any or all of them to be created.
Default output option is -C, the output file will be named 'fastagenome' + ".csm".

-A alignedOut    Is a concatenation of results in the same format 
                 as the erpin model supplied with -m.

-L logOut        Is a human-readable report, condensed to show only 
                 the area around the erpin elements that were searched for.
                 
-X xmlOut        This is a file containing a series of XML documents, one
                 document per RNA.

-C customOut     Is a simple text output. The RNA information is the same as the one produced
                 by the -X option.
                 
-M ApcOut        This is a file containing a list of AnnotPair (AnnotPairCollection) for MFannot.

Other options:
--------------
-l               List of available models. Create with Menufile. Accepted value 1 or 2.

-D               Turn on debug mode; some temporary files will be left in
                 a subdirectory created in /tmp, available for inspection.
                 
-P               Used to define the number of processor.
                 Default RNAfinder look at the number of processor.
                 
-T               Define the temporary work directory.

-a               Mail address in order to send result by mail.

-pc              Percentage of cutoff values defined by erpin.

-r               Removing duplicated sequences in data file.
USAGE
exit 1;
}

sub CreateMenuList {
    my ($menu_file,$lvl) = @_;
    
    my $Menu = "";
    my $menulist = $MENU_LIST;
    for my $ItemSet_name ( sort keys %$menulist ) {
        my $ItemSet    = $menulist->{$ItemSet_name};
        my $OriName    = $ItemSet->{'OriName'};
        my $ModComment = $ItemSet->{'Comment'};
        $Menu .= "\nModel name : $OriName\n";
        $Menu .= "Comment    : $ModComment\n";
           $ItemSet = $ItemSet->{'Set'};
        my $Item_count = 1;
        foreach my $Item_num ( sort { $a <=> $b } keys %$ItemSet){
            my $Item = $ItemSet->{$Item_num};
            my $erpinArg  = $Item->get_erpinArg()   || "";
            my $modelFile = $Item->get_modelFile()  || "";
            my $posAc     = $Item->get_AcId()       || "";
            my $label     = $Item->get_Label()      || "";
            my $comment   = $Item->get_comment()    || "";
            my $cutoff    = $Item->get_cutoff()     || "";
            
            if ($lvl == 2 ) {
                $Menu .= "\tItem$Item_num\n";
                $Menu .= "\t\terpin arguments    : $erpinArg\n"  if $erpinArg;
                $Menu .= "\t\tModel file         : $modelFile\n" if $modelFile;
                $Menu .= "\t\tCutoff             : $cutoff\n"    if $cutoff;
                $Menu .= "\t\tAnticodon position : $posAc\n"     if $posAc;
                $Menu .= "\t\tLabel              : $label\n"     if $label;
                $Menu .= "\t\tComment            : $comment\n"   if $comment && $comment ne '""';
            }
            else {
                $Menu .= "\tItem$Item_num : $comment\n";
            }
            $Item_count++;
        }
    }
    return $Menu;
}

sub CheckModuleList {
    my $menulist = $MENU_LIST;

    # Make verification must have complete list
    for my $ItemSet_name ( sort keys %$menulist ) {
        my $ItemSet   = $menulist->{$ItemSet_name}->{'Set'};
        # If one Item have module all Item for one model must have module
        my $count_module = 0;
        my $count_Item   = scalar( keys %$ItemSet);
        foreach my $Item_num (keys %$ItemSet){
            my $Item    = $ItemSet->{$Item_num};
            my $module  = $Item->get_module() || "";
            next if !$module;
            my @mods = split(/,/, $module);
            @mods = sort { $a <=> $b } @mods;
            foreach my $mod (@mods) {
                $mod =~ s/\s+//g;
                die "Field module for '$ItemSet_name' item '$Item_num' must be a list of integer"
                    if $mod !~ /^\d+$/;
            }
            my %count = ();
            foreach my $mod (@mods) { $count{$mod}++ };
                foreach my $element (keys %count) {
                die "Field module for '$ItemSet_name' item '$Item_num' can't have duplicate number\n." 
                    if $count{$element} > 1;
            }  
            $Item->set_modTab(\@mods);
            $count_module++ if $module;
        }
        die "All Item for '$ItemSet_name' must have module field.\n" if $count_module != $count_Item && $count_module != 0;
    }
}

###########################
# Check arguments numbers #
###########################
if (@ARGV == 0) {
	print "There were no arguments passed on the command line. This program takes arguments\n";
	&Usage();
}

##################################
# Global variables and constants #
##################################
$|=1;

# Input options
my $DATAFILE    = ""; # -d
my $MODELNAME   = ""; # -m
my $GENETICCODE = ""; # -c

# Default parameters for the script
my $DEBUG       = 0;  # -D
my $LIST        = 0;  # -l
my $PARALLELISM = 0;  # -P
my $MAIL_ADR    = ""; # -a 

# Output options
my $ERPINOUTFILE   = ""; # -E
my $ALIGNEDOUTFILE = ""; # -A
my $REPORTFILE     = ""; # -L
my $XMLOUTFILE     = ""; # -X
my $CUSTOMOUTFILE  = ""; # -C
my $APCOUTFILE     = ""; # -M
my $REMOVEINTAR    = ""; # -r
my $TMP_DIR        = "/tmp/RNAfinder.$$"; # -T
my $LOGOUTFILE_NOTDEF = 0;

# Other
my $CODON_TABLE   = "";
my $POURCENT      = 0;
my $POURCENTISDEF = undef;
my $TOTALSTART    = time;

###########################
# Deal with the arguments #
###########################

for (;@ARGV;) {
    # Add in the regex [] ALL single-character command-line options
    my ($opt,$arg) = ($ARGV[0] =~ /^-([adcmlrALXCMPDT]|pc)(.*)$/);
    last if ! defined $opt;
    # Add in regex [] ONLY single-character options that
    # REQUIRE an argument, except for the 'd' debug switch.
    if ($opt =~ /[adcmlALXCMPT]|pc/ && $arg eq "") { 
        if (@ARGV < 2) {
            print "Argument required for option \"$opt\".\n";
            exit 1;
        }
        shift;
        $arg=$ARGV[0];
    }
    $MAIL_ADR       = $arg              if $opt eq 'a'; 
    $POURCENT       = $arg              if $opt eq 'pc';
    $POURCENTISDEF  = 1                 if $opt eq 'pc';
    $GENETICCODE    = $arg              if $opt eq 'c';
    $DATAFILE       = $arg              if $opt eq 'd';
    $MODELNAME      = $arg              if $opt eq 'm';
    $LIST           = $arg              if $opt eq 'l';
    $ALIGNEDOUTFILE = $arg              if $opt eq 'A';
    $REPORTFILE     = $arg              if $opt eq 'L';
    $XMLOUTFILE     = $arg              if $opt eq 'X';
    $CUSTOMOUTFILE  = $arg              if $opt eq 'C';
    $APCOUTFILE     = $arg              if $opt eq 'M'; 
    $DEBUG          = ($arg ? $arg : 1) if $opt eq 'D';
    $REMOVEINTAR    = ($arg ? $arg : 1) if $opt eq 'r';
    $TMP_DIR        = $arg              if $opt eq 'T';
    $PARALLELISM    = $arg              if $opt eq 'P';
    shift;
}

if ($LIST) {
    die "Available value for -l is 1 or 2!\n" 
        if $LIST != 1 && $LIST != 2;
    print &CreateMenuList($MENU_FILE,$LIST);
    exit 1;
}

# Parsing Erpin Arguments
my @NAME_LIST = split(/,/,$MODELNAME);
my $NAME_LIST = {};
foreach my $arg (@NAME_LIST){
    my ($name,$list) = ("","");
    $arg =~ m/(.+)\((.+)\)/ ? ($name,$list) = ($1,$2) : $name = $arg;
    $NAME_LIST->{$name} = lc($list);
}


#################################
# Validate command-line options #
#################################

&Usage if @ARGV > 0 || $DATAFILE eq "" || $MODELNAME eq "";
if (     $ALIGNEDOUTFILE eq "" && $REPORTFILE    eq "" 
      && $XMLOUTFILE     eq "" && $CUSTOMOUTFILE eq "" 
      && $APCOUTFILE eq "") {
      $LOGOUTFILE_NOTDEF = 1;
}

my @AF_HOSTS= qw( megasuno.bcm.umontreal.ca
                  megasuno);
if ($MAIL_ADR) {
die "RNAfinder can only run with -a option on : megasuno"
    unless scalar(grep( $_ eq hostname(), @AF_HOSTS));
}

################
# Trap Signals #
################

sub SigCleanup { # private
     die "\nExiting: received signal \"" . $_[0] . "\".\n";
}
$SIG{'INT'}  = \&SigCleanup;
$SIG{'TERM'} = \&SigCleanup;
$SIG{'HUP'}  = \&SigCleanup;
$SIG{'QUIT'} = \&SigCleanup;
$SIG{'PIPE'} = \&SigCleanup;
$SIG{'ALRM'} = \&SigCleanup;

##########################################################
# Check Sequences file and define models directory       #
##########################################################

unless (-d $TMP_DIR) { mkdir($TMP_DIR,0777); }

my $HOME = $ENV{"HOME"};
# Models and lib path
my @MOD_PATH = ("./Erpin_models"); # You can add other search directories here

push(@MOD_PATH,split(/:/,$ENV{"ERPIN_MOD_PATH"}))
    if $ENV{"ERPIN_MOD_PATH"};

my $MODEL_PATH = "";
foreach my $path (@MOD_PATH) {
    next if !(-d $path);
    $MODEL_PATH = $path;
    last if $MODEL_PATH;
}

$MODEL_PATH =~ s/\/$//;
die "No path for ErpinModels were found\n"
    if !$MODEL_PATH;
    
if (defined($POURCENTISDEF)) {
    die 'Value of option -pc must be include between 0 and 100' 
        if !($POURCENT > 0 && $POURCENT <= 100);
}
&checkFile($DATAFILE);

my %uniToThree = ( A => 'Ala', R => 'Arg', N => 'Asn', D => 'Asp', C => 'Cys', Q => 'Gln', E => 'Glu',
                   G => 'Gly', H => 'His', I => 'Ile', L => 'Leu', K => 'Lys', M => 'Met', F => 'Phe',
                   P => 'Pro', S => 'Ser', T => 'Thr', W => 'Trp', Y => 'Tyr', V => 'Val', B => 'Asx',
                   Z => 'Glx', X => 'Xaa', '*' => 'Ter');

########
# MAIN #
########

# Create non-redundant versions of the genome file.
my $NB_PROC   = &DefineNumberOfProcessor();
$PARALLELISM  = $NB_PROC if !$PARALLELISM;
if ($PARALLELISM > $NB_PROC) {
   print "This computer have only $NB_PROC processor, used all processor\n";
   $PARALLELISM = $NB_PROC;
}
my $Ret_Rseqs = {};
my ($nr_genome,$Rseqs) = &CreateNrGenome();
my $AllErpinResult     = &CreateNrModelAndRunErpin();
&SelectResult($AllErpinResult);
my ($short_summary,$screen_summary,$mail_summary) = &CreateRNAPredictions($AllErpinResult);
&ScreenOutput($mail_summary,$screen_summary);
&ListOfEmptySeq($Ret_Rseqs,$Rseqs);
&sendMail() if $MAIL_ADR;
print "Temporary work directory $TMP_DIR NOT cleaned up ...\n" if $DEBUG; 
system("/bin/rm","-rf",$TMP_DIR) if -d $TMP_DIR && !$DEBUG;

#End of the script
printf("%-70s", "Finished");
print strftime("\%H:\%M:\%S", gmtime(time-$TOTALSTART))."\n";
if (-d $TMP_DIR){
my $filename = basename($DATAFILE);
rename("$TMP_DIR/$filename.log.tmp","$TMP_DIR/$filename.log");
rename("$TMP_DIR/$filename.csm.tmp","$TMP_DIR/$filename.csm");
rename("$TMP_DIR/$filename.xml.tmp","$TMP_DIR/$filename.xml");
rename("$TMP_DIR/$filename.apc.tmp","$TMP_DIR/$filename.apc");
rename("$TMP_DIR/$filename.ali.tmp","$TMP_DIR/$filename.ali");
}
exit(0);

#############################
#   S U B R O U T I N E S   #
#############################

###############################
# Creation of temporary files #
###############################

sub DefineNumberOfProcessor {
    my $nb_proc = "$TMP_DIR/nb_proc";
    system("grep processor /proc/cpuinfo > $nb_proc");
    my $count_proc = 0;
    my $infh = new IO::File "<$nb_proc"
        or die "Can't read from file '$nb_proc': $!\n";
    while (my $line = <$infh>) {
        next if $line !~ m/^processor\s*:\s*\d+$/;
        $count_proc++;
    }
    return $count_proc;
}

sub CreateNrGenome {
    my $nr_genome = "$TMP_DIR/genome.fa";
    my $Rseqs = &CopyWithoutDuplicates($DATAFILE,$nr_genome,"","RemoveDuplicatesByIDs|ReturnHash",50);
    return ($nr_genome,$Rseqs);
}

sub CreateNrModel {
    my $model_file    = shift;
    my $erpinMaskNums = shift;
    my $Item_num      = shift;
    my $MOD_PATH      = shift;
    
    my $ModelFilePath = "";
    foreach my $path (@$MOD_PATH) {
        next if !(-f "$path/$model_file");
        $ModelFilePath = "$path/$model_file";
        last;
    }
    die "No file found for model '$model_file'.\n" if !$ModelFilePath; 
    
    # Create non-redundant versions of the
    # model file and the genome file.
    my $file_name = basename($model_file);
    my $nr_model  = "$TMP_DIR/$file_name"."${Item_num}";
    return if (-f $nr_model);
    my $LinStruct  = PirObject::LinStruct->new();
    my $model_fh   = new IO::File "<$ModelFilePath"
        or die "Cannot read model output '$ModelFilePath': $!\n";
    $LinStruct->ImportFromMultipleAlignment($model_fh); # will close the filehandle
    &CopyWithoutDuplicates($ModelFilePath,$nr_model,$LinStruct,"RemoveDuplicatesBySeqs|KeepRawSeqs",999,$erpinMaskNums,$nr_model);
    return ($nr_model);
}

# Yet another FASTA parser/loader/validator/copier.
sub CopyWithoutDuplicates {
    my $infile        = shift;
    my $outfile       = shift;
    my $LinStruct     = shift;
    my $options       = shift || "ByIDs"; # Options: BySeq|ByIDs|RawSeq|ReturnHash 
    my $width         = shift || 50;
    my $erpinMaskNums = shift;
    my $nr_model      = shift;

    my $infh = new IO::File "<$infile"
        or die "Can't read from file '$infile': $!\n";
    my $outfh = new IO::File ">$outfile"
        or die "Can't write to file '$outfile': $!\n";
    my $cleanfh = new IO::File ">${outfile}.RemoveSeqName"
        or die "Can't write to file '${outfile}.RemoveSeqName': $!\n";
    
    # Option parsing
    my $byseq      = 1 if $options =~ /byseq/i;  # byids is converse of this
    my $rawseq     = 1 if $options =~ /rawseq/i;
    my $returnhash = 1 if $options =~ /returnhash/i;

    my %seenIds  = (); # FASTA IDs (for uniqueness)
    my %seenSeqs = (); # SEQ DATA (for uniqueness)
    my %list_seq = (); # SEQ DATA (for uniqueness) not Interest_seq
    my %head_dup = (); # DUPLICATE FASTA IDs with =! sequence
    my %ID_seq   = (); # FASTA IDs (for uniqueness) value = sequence

    my $header        = "";
    my $id            = "";
    my $seq           = "";
    my $Interest_seq  = "";
    my $nb_dupli      = 0;
    
    my %IdToSeq = (); # all seq data in a hash; returned if option ReturnHash is true

    while (my $line = <$infh>) {
        next if $line =~ m#^\s*$|^;#;

        # Seq data? Append.
        if ($line !~ m/^>\s*(.+)/) {
            $line     =~ tr/a-z\-\*A-Z//cd unless $rawseq;
            $Interest_seq = &CreateSeq($LinStruct,$line,$erpinMaskNums) if $nr_model && ($nr_model eq $outfile); 
            $seq     .= $line;
            next;
        }

        # Header line.
        my $newid = $1; # from regex above
           $newid = substr($newid,0,57) if length($newid) > 57 && !$byseq;

        # Dump previous record if needed
        my $isdupl = 0;
        if (defined($byseq)) {
            $isdupl = $seenSeqs{$Interest_seq};
        }
        else {
            $isdupl = 1 if $ID_seq{$id} && $ID_seq{$id} eq $seq;
            $isdupl = 1 if $list_seq{$seq};
            ++$head_dup{$id} if $ID_seq{$id} && $ID_seq{$id} ne $seq;
        }
        
        if ($isdupl && ( $byseq || $REMOVEINTAR)) {
            print STDERR "Ignored duplicated entry in '$infile': $id\n" if $DEBUG;
            print $cleanfh "$id\n";
        } 
        elsif ($id) { # if we have the previous seq in memory
            if ($isdupl && !$byseq ) { # Special case
                print STDERR "Ignored duplicated entry in '$infile': $id\n" if $DEBUG;
                print $cleanfh "$id\n";
                $nb_dupli++;
            }
            my $name_for_IdToSeq = !$head_dup{$id} ? $id : "$id ".$head_dup{$id};
            print $outfh ">$name_for_IdToSeq\n"; # cleaned header with simple ID
            print $outfh $seq                        if     $rawseq;
            &DumpFormatedSeq($outfh,\ $seq, $width)  unless $rawseq;
            $IdToSeq{$name_for_IdToSeq}=$seq if $returnhash;
            $byseq ? ++$seenSeqs{$Interest_seq} : ++$seenIds{$id};
            $ID_seq{$id} = $seq if !$byseq;
            ++$list_seq{$seq};
        }
        ($header,$id,$seq)  = ($line,$newid,"");
    }

    # Handle last seq in file
    my $isdupl = 0;
    if (defined($byseq)) {
        $isdupl = exists($seenSeqs{$seq});
    }
    else {
        $isdupl = 1 if $ID_seq{$id} && $ID_seq{$id} eq $seq;
        $isdupl = 1 if $list_seq{$seq};
        ++$head_dup{$id} if $ID_seq{$id} && $ID_seq{$id} ne $seq;
    }
    
    if ($isdupl && ($byseq || $REMOVEINTAR)) {
        print STDERR   "Ignored duplicated entry in '$infile': $id\n" if $DEBUG && $seenIds{$id} == 2;
        print $cleanfh "$id\n" if $seenIds{$id} == 2;
    } elsif ($id) { # if we have the previous seq in memory
        if ($isdupl && !$byseq ) { # Special case
            print STDERR "Ignored duplicated entry in '$infile': $id\n" if $DEBUG;
            print $cleanfh "$id\n";
            $nb_dupli++;
        }
        my $name_for_IdToSeq = !$head_dup{$id} ? $id : "$id ".$head_dup{$id};
        print $outfh ">$name_for_IdToSeq\n"; # cleaned header with simple ID
        print $outfh $seq                        if     $rawseq;
        &DumpFormatedSeq($outfh,\ $seq, $width)  unless $rawseq;
        $IdToSeq{$name_for_IdToSeq}=$seq if $returnhash;
        $byseq ? ++$seenSeqs{$seq} : ++$seenIds{$id};
        $ID_seq{$id} = $seq if !$byseq;
        ++$list_seq{$seq};
    }

    $outfh->close();
    $infh->close();
    $cleanfh->close();
    
    if ($options !~ /byseq/i) {
        my $outfile_basename = basename("${outfile}.RemoveSeqName");
        if (!$MAIL_ADR && $nb_dupli > 0 && !$REMOVEINTAR) {
            system("cp","${outfile}.RemoveSeqName","./ListSeqName");
            print "\nRemoved $nb_dupli identical sequences from the data, listed in: ListSeqName\n";
        }
        if (!$MAIL_ADR && $REMOVEINTAR) {
            system("cp","${outfile}.RemoveSeqName","./RemoveSeqName");
            print "\nList of duplicates removed from target sequences: RemoveSeqName\n";
        }
    }
    return(\ %IdToSeq) if $returnhash;
    1;
}

sub DumpFormatedSeq {
    my $fh     = shift;
    my $seqref = shift;
    my $width  = shift || 50;

    my $tot = length($$seqref);

    for (my $i=0;$i<$tot;$i += $width) {
        my $rest = $tot - $i;
        $rest = $width if $rest > $width;
        print $fh substr($$seqref,$i,$rest),"\n";
    }
}
 
###############
# Run erpin   #
###############

sub CreateNrModelAndRunErpin {
    my $AllErpinResult = {};
    
    my $FileForCut = &CreateFileForCutoff if $POURCENTISDEF;
    foreach my $name (sort(keys %$NAME_LIST)) {
        my @list = split(/\|/, $NAME_LIST->{$name});
        my $model_list = $MENU_LIST->{lc($name)};
        die "No model found for '$name'\n" if !$model_list;
        my $order      = $model_list->get_Order();
        my $ItemSet    = $model_list->{'Set'};
        print "\nProcessing $name\n";
        $LIST_OF_SEARCHED .= $LIST_OF_SEARCHED eq "" ? $name : "_$name";

        &CreateNrModelForAllItems($ItemSet,$name,\@list);
        &DefineCutoffForAllItems($ItemSet,$FileForCut) if $POURCENTISDEF;
        &RunErpinForAllItems($ItemSet);
        my $erpin_res = &CreateErpinResultForAllItems($ItemSet);
        $AllErpinResult->{"$order"} = [$name,$erpin_res];
    }
    return $AllErpinResult;
}

sub CreateNrModelForAllItems {
    my ($ItemSet,$name,$list) = @_;

    foreach my $sub_clans (@$list) {
        my $isInList = 0;
        foreach my $Item_num ( sort { $a <=> $b } keys %$ItemSet) {
            my $Item  = $ItemSet->{$Item_num};
            my $label = $Item->get_Label();
            $isInList = 1 if lc($sub_clans) eq lc($label);
        }
        print "No sub clans with label $sub_clans in $name\n" if !$isInList;
    }
    
    foreach my $Item_num ( sort { $a <=> $b } keys %$ItemSet) {
        my $Item          = $ItemSet->{$Item_num};
        my $label         = lc($Item->get_Label());
        next if !grep(/$label/,@$list) && scalar(@$list);
        my $erpinArg      = $Item->get_erpinArg();
        my $modelFile     = $Item->get_modelFile();
        my @ERPINARGS     = split(/\s+/,$erpinArg);
        my @erpinMaskNums = ParseErpinArgs(@ERPINARGS);
        my $model_file    = &CreateNrModel($modelFile,\@erpinMaskNums,$Item_num,\@MOD_PATH);
        $Item->set_ModelFile($model_file);
        my $erpinSuf      = "${TMP_DIR}/${name}_$Item_num";
        my $erpinOut      = "$erpinSuf.out";
        my $erpinErr      = "$erpinSuf.err";
        $Item->set_erpinOut($erpinOut);
        $Item->set_erpinErr($erpinErr);
        $Item->set_erpinMaskNums(\@erpinMaskNums);
        $Item->set_lowest($erpinMaskNums[0]);
    }
}

sub DefineCutoffForAllItems {
    my ($ItemSet,$FileForCut) = @_;
    
    print "Define erpin cutoff :\n";
    foreach my $Item_num ( sort { $a <=> $b } keys %$ItemSet) {
        my $Item       = $ItemSet->{$Item_num};
        next if !$Item->get_ModelFile();
        my $comment     = $Item->get_comment();
        print "\tFor item $comment\n";
        next if !$POURCENT;
        my $model_file = $Item->get_ModelFile();
        my $erpinArg   = $Item->get_erpinArg();
        my $cutoff     = $Item->get_cutoff();
        $cutoff        = &DefineCutoffWithPourcent($model_file,$FileForCut,$erpinArg,$cutoff);
        $Item->set_cutoff($cutoff);
    }
}

sub CreateFileForCutoff {
    my $FileForCut = "$TMP_DIR/for_cutoff";
    open(CUTOFF, ">$FileForCut") or die ("Could not open file for cutoff!\n");
    print CUTOFF ">SeqForCutoff\nT\n";
    close(CUTOFF);
    return $FileForCut;
}

sub DefineCutoffWithPourcent {
    my ($model_file,$FileForCut,$erpinArg,$cutoff) = @_;

    my ($erpinOut,$erpinErr) = ("$FileForCut.out","$FileForCut.err");
    &RunErpin($FileForCut,$model_file,$erpinArg,$erpinOut,$erpinErr);
    my $BestCutoff   = &DefineBestcutoff($erpinOut);
    my $newCutoff    = " ";
    my $HaveNegValue = 0;
    foreach my $b_cutoff (@$BestCutoff) {
        if ($b_cutoff < 0) {
            $HaveNegValue = 1;
            print "\tCutoff defined by erpin contain negative value '$b_cutoff', using cutoff of user.\n";
            last;
        }
        my $PourcentCutoff = ($b_cutoff * $POURCENT) / 100;
        $PourcentCutoff = arrondi($PourcentCutoff,1);
        $newCutoff .= "$PourcentCutoff ";
    }
    $newCutoff = $cutoff if $HaveNegValue;
    return $newCutoff;
}

sub arrondi {
    my ($n,$precision) = @_;    
    return int((10**$precision)*$n + 0.5) / (10**$precision);
}

sub DefineBestcutoff {
    my $OutFile = shift;
    my $BestCutoff = [];
    
    my $ifh = new IO::File "<$OutFile";
    while (my $line = <$ifh>) {
        next if $line !~ m/^cutoff:\s+(.+)/;
        push(@$BestCutoff,$1);
    }
    return $BestCutoff;
}

sub RunErpinForAllItems {
    my ($ItemSet) = @_;
    
    my @Items_todo = sort { $a <=> $b } keys %$ItemSet;
    
    for (my $i = @Items_todo-1 ; $i >= 0 ; $i--) {
        my $Item_num = $Items_todo[$i];
        my $Item     = $ItemSet->{$Item_num};
        next if $Item->get_ModelFile();
        splice(@Items_todo, $i, 1);
    }
    
    my %pidsItems=();
    my %Itemstarttime=();
    print "Run erpin :\n";
    for (;;) {
        my $ongoing = scalar(keys %pidsItems);
        last if !@Items_todo && !$ongoing;
        
        if ($ongoing >= $PARALLELISM || !@Items_todo) {
            my $donepid = wait;
            next if $donepid < 0; # should never happen?
            my $Item_num = delete($pidsItems{$donepid}) || next;
            my $start    = $Itemstarttime{$Item_num};
            my $Item     = $ItemSet->{$Item_num};
            my $comment  = $Item->get_comment();
            my $time     = strftime("\%H:\%M:\%S", gmtime(time-$start));
            $Item->set_time($time);
            printf("%-50s", "Completed $comment");
            print "$time\n";
            next;
        }
        my $Item_num = shift(@Items_todo);
        
        # Manage child subprocesses.
        if (my $pid = fork()) {
            $pidsItems{$pid}=$Item_num;
            my $Item     = $ItemSet->{$Item_num};
            my $comment = $Item->get_comment();
            $Itemstarttime{$Item_num}=time;
            print "\tProcessing $comment\n";
            next;
        }
        
        # Child starts here
        my $Item     = $ItemSet->{$Item_num};
        my $nr_model = $Item->get_ModelFile();
        my $erpinArg = $Item->get_erpinArg();
        my $cutoff   = $Item->get_cutoff();
        my $erpinOut = $Item->get_erpinOut();
        my $erpinErr = $Item->get_erpinErr();
        
        $erpinArg =~ s/"//g;        
        my $ret = "";
        if (defined($cutoff)) {
            print STDERR "nice -19 erpin $nr_model $nr_genome $erpinArg -cutoff $cutoff > $erpinOut 2> $erpinErr\n" if $DEBUG;
            $ret = system("nice -19 erpin $nr_model $nr_genome $erpinArg -cutoff $cutoff > $erpinOut 2> $erpinErr");
        }
        else {
            print STDERR "nice -19 erpin $nr_model $nr_genome $erpinArg > $erpinOut 2> $erpinErr\n" if $DEBUG;
            $ret = system("nice -19 erpin $nr_model $nr_genome $erpinArg > $erpinOut 2> $erpinErr");
        }
        
        if (($ret >> 8) > 1 || (-s "$erpinOut" == 0) ) {
            print STDERR "There was an error running 'erpin'.\n";
            print STDERR "Content of STDERR output:\n";
            system("cat",$erpinErr);
        }
        exit 0;
    }
}

sub CreateErpinResultForAllItems {
    my ($ItemSet) = @_;
    
    my $erpin_res  = [];
    foreach my $Item_num ( sort { $a <=> $b } keys %$ItemSet) {
        my $Item          = $ItemSet->{$Item_num};
        my $model_file    = $Item->get_ModelFile();
        next if !$Item->get_ModelFile();
        my $erpinArg      = $Item->get_erpinArg();
        my $erpinMaskNums = $Item->get_erpinMaskNums();
        my $lowest        = $Item->get_lowest();
        my $erpinOut      = $Item->get_erpinOut();
        my $time          = $Item->get_time();
        my $comment       = $Item->get_comment();
        my $erpinSuff     = $erpinOut;
           $erpinSuff     =~ s/.out$//;
        my $erpinLog      = "$erpinSuff.log";
        my $erpinAli      = "$erpinSuff.ali";
        
        my $erpinResult   = &MakeModel($model_file,$erpinOut,$erpinLog,$erpinAli,0,100,$lowest,$erpinMaskNums);
        next if !$erpinResult;
        
        # Add info foreach erpinResult
        my $modTab        = $Item->get_modTab();
        $erpinResult->set_modTab($modTab);
        $erpinResult->set_NumItem($Item_num);
        $erpinResult->set_time($time);
        my $label         = $Item->get_Label();
        $erpinResult->set_Label($label);
        $erpinResult->set_comment($comment);
        
        # Add anticodon information
        my $Ac_id         = $Item->get_AcId();
        &DefineCodonTable($GENETICCODE) if $Ac_id && !$CODON_TABLE;
        &AddAcInfo($erpinAli,$Ac_id,$erpinResult) if $Ac_id;
        push(@$erpin_res,$erpinResult);
    }
    return $erpin_res;
}

sub RunErpin {
    my ($nr_genome,$nr_model,$erpinArg,$erpinOut,$erpinErr,$Item_num,$cutoff) = @_;
    
    $erpinArg =~ s/"//g;
    print STDERR "Running erpin for item $Item_num...\n" if $Item_num;
    
    my $ret = "";
    if (defined($cutoff)) {
        print STDERR "nice -19 erpin $nr_model $nr_genome $erpinArg -cutoff $cutoff\n" if $DEBUG;
        $ret = system("nice -19 erpin $nr_model $nr_genome $erpinArg -cutoff $cutoff > $erpinOut 2> $erpinErr");
    }
    else {
        print STDERR "nice -19 erpin $nr_model $nr_genome $erpinArg\n" if $DEBUG;
        $ret = system("nice -19 erpin $nr_model $nr_genome $erpinArg > $erpinOut 2> $erpinErr");
    }
    
    if (($ret >> 8) > 1 || (-s "$erpinOut" == 0) ) {
        print STDERR "There was an error running 'erpin'.\n";
        print STDERR "Content of STDERR output:\n";
        system("cat",$erpinErr);
        exit 0; # cleanup will occur in END {}
    }
}

sub ParseErpinArgs {
# erpin giD.epn test.seq 2,21 -add 2 3 -add 4 5 6 8 -add 9 -add 11 12 13 14 15 -add 17 18 20 21 -logzero -2 -cutoff 7 13 22 39 52
	my @command = @_;
	my @numbers;
	my $flag = 0;
	
	foreach my $bit (@command) {
		chomp($bit);
		
		if($bit =~ m/^-.*$/) {
			if($bit =~ m/^-add$/) { $flag = 1;}
			else { $flag = 0;}
			next;
		}
		if( ($flag == 1) and ($bit =~ m/^\d+$/) ) {
			push @numbers, $bit; 
		}
	}
	return(sort { $a <=> $b } @numbers);
}

###############################
#   MakeModel and Subroutines #
###############################

# Function which create a new training set with or without evalue filter
sub MakeModel {
    ############################
    ## Variables & arguments  ##
    ############################
    my $modelFile     = shift;
    my $outputfile    = shift;
    
    my $reportfile    = shift; # where we store our new report
    my $alignedfile   = shift; # where we store our aligned out
    
    my $ECO_LOW       = shift;
    my $ECO_UP        = shift;
    my $lowest        = shift;
    my $erpinMaskNums = shift;
    my $label         = shift;
    
    my $ErpinResult   = new PirObject::erpinResult();
    my $Alignments    = [];
    
    my ($outSeqsRef, $outSeqEvalueOrderRef, $outSeqOriginalOrderRef, $dirRef, $startRef, $endRef, $eValueRef, $upper, $lower, $origNumResults);
    
    ############################
    ## Read Erpin output file ##
    ############################
    open(OUTPUT, $outputfile) or die ("Could not open output file '$outputfile': $!\n");
    my @erpinOutputFile = <OUTPUT>;
    close(OUTPUT);
    #If there is no results in this file => quit with error message
    &noErpinResultError() if @erpinOutputFile == 0;
    
    ###########################################################################################
    ## Lecture des sequences dans le fichier output erpin avec prise en compte bornes evalue ##
    ###########################################################################################
    ($outSeqsRef, $outSeqEvalueOrderRef, $outSeqOriginalOrderRef, $dirRef, $startRef, $endRef, $eValueRef, $upper, $lower, $origNumResults) = GetSeqFromOutputFile($ECO_LOW, $ECO_UP, \@erpinOutputFile);
    
    my %outSeqs              = %$outSeqsRef;
    my @outSeqsEvalueOrder   = @$outSeqEvalueOrderRef;
    my @outSeqsOriginalOrder = @$outSeqOriginalOrderRef;
    my %dir                  = %$dirRef;
    my %start                = %$startRef;
    my %end                  = %$endRef;
    my %eValue               = %$eValueRef;
    
    #####################
    ## Read Model File ##
    #####################
    open(MODEL, $modelFile) or die ("Could not open output file!");
    my @modelFile = <MODEL>;
    close(MODEL);
    
    #Get the sequence consensus for modelFile.
    my $consensus = &GetConsensus($modelFile);
    #Get the structures lines from the model file
    my $structure = GetStructureFromModelFile(\@modelFile);
    #Count number of sequences in the model
    my $numModels = @outSeqsEvalueOrder;
    $ErpinResult->set_OriSol($numModels);
    
    #############################
    # 6. Build new training set #
    #############################
    
    #creation of new model & log files
    my $outputModel   = "$alignedfile";
    my $modelLogFile  = "$reportfile";
    my $res_ali  = "";
    my $res_log  = "";
    my $res_tRNA = "";
	
    #Print structure in the training set
    $res_ali .= ">structure\n";
    $res_ali .=  $structure;
    $res_ali .=  ">consensus\n";
    $res_ali .=  "$consensus\n";
    
    ## BEGIN : HEADER LOG FILE
    $res_log .=  "*************************************************\n";
    $res_log .= "Condensed alignment for $outputModel\n";
    $res_log .= "*************************************************\n";
    $res_log .= "$numModels matches\n";
    $res_log .= "Label: $label\n" if defined $label;
    $res_log .= "\n";
    
    ## END : HEADER LOG FILE 
    
    my $prefixLen       = GetStructurePos($structure, $lowest);
    my $prefixIndex     = $prefixLen;
    my ($suffixLen,$suffixIndex) = (0,0);
    my $structureLen    = GetStructureLength($structure);
    my $lenSeq          = 0;
    # Need to loop through all sequences first for report
    # to see the max length of each sequence
    # This is mainly because the sequences/models in the report
    # need to be aligned, and if we don't know their lengths
    # and gaps, then the alignments will be bad.
    
    my @maxBitLen;
    my @preLoop = @outSeqsOriginalOrder;
    
    foreach my $key (@preLoop) {
        my($arrayKey, $dirKey, $hashKey) = split("<->", $key);
        my @reportHeader = split(" ", $hashKey);
        my $tmpSeq = @{$outSeqs{$hashKey}}[$arrayKey];
        my @seqBits = split(/\./, $tmpSeq);
		
        for(my $i=0;$i<@seqBits;$i++) {
            if($seqBits[$i] =~ m/^[\-]+$/) { $seqBits[$i] = "";}
                        if(!defined($maxBitLen[$i]))                 { $maxBitLen[$i] = length($seqBits[$i]); }
            elsif(length($seqBits[$i]) > $maxBitLen[$i]) { $maxBitLen[$i] = length($seqBits[$i]); }
            #If this is lowercase
            #PR# elsif($seqBits[$i] =~ m/[a-z]/) { $seqBits[$i] =~ s/-//g; }
        }
    }
    
    my $BracketModel = &MakeLogBrackets($structure, \@maxBitLen, $erpinMaskNums);
    # Maybe must be change
    $res_log .= "Species name                       E-value   # of nt     Start..Stop      Str  #  Structure\n";
    $res_log .= "------------------------------  ---------- --------- -------------------- --- --- ------------------\n";
    #Fields:           ssssssssssssssssssssssssssssss| EEEEEEEEEE NNNNNNNNN PPPPPPPPP..PPPPPPPPP SS MMM [[[...
    #Fields:           0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789
    $res_log .= "                                                                                 ";
    $res_log .= $BracketModel . "\n";
    
    my @sortedList = @outSeqsOriginalOrder;
	
#######  REMARK :
#######  In this part, there is a lots of "length($var)".
#######  I think they can be replaced by temporary variables but sometimes i was thinking that i causes somes crashes.
#######  
	
    foreach my $key (@sortedList) {
        # Remember that the $key here contains three values;
        # but we only care aobut the $arrayKey and the $hashKey.
        # The $dirKey here is only in there to make all keys in 
        # the hash unique 
        my($arrayKey, $dirKey, $hashKey) = split("<->", $key);
        $key = $hashKey;
        my $tmpSeq = @{$outSeqs{$hashKey}}[$arrayKey];
        my $evalue = @{$eValue{$hashKey}}[$arrayKey];
        my $start  = @{$start{$hashKey}}[$arrayKey];
        my $stop   = @{$end{$hashKey}}[$arrayKey];
        my $dir    = @{$dir{$hashKey}}[$arrayKey];
        my $seq    = $Rseqs->{$key};
           $lenSeq = length($seq);
        my $aliNumber = ($arrayKey+1);
        
        # Copy sequence in the .log file
        my @reportHeader = split(" ", $key);
        if(length($reportHeader[0]) > 30) {
            $reportHeader[0] = substr($reportHeader[0], 0, 30);
        }
        
        # Report
        # Allo.macrogynus.mt      6.55e-24   55667   6877..7327  FW   1  TATACAATCG CTA C C GACTG gtt...(1151)...ctt AATGTA CAGTC G GTATTTCCAA
        my $reportSeq  = makeReportSeq($tmpSeq, @maxBitLen);
        my $HeadForLog = sprintf ("%-30s| %10s %9s %9s..%-9s %s %3s ",
                        $reportHeader[0],
                        $evalue,
                        length($Rseqs->{$hashKey}),
                        $start,
                        $stop,
                        $dir,
                        $aliNumber);
                
        $res_log .= $HeadForLog;
        $res_log .= $reportSeq . "\n";
        
        # Copy sequence in the .ali file
        # Make all uppercase
        $tmpSeq = uc($tmpSeq);
        $tmpSeq =~ s/\.//g;
        
        # CREATE HEADER IN THE MODEL FILE    
        # Make header
        my $HeadForAli;
        my $header;
        my $keyLen = length($key);
        # Trucate sequence name if greater than 60 characters long
        if($keyLen > 60) { $header = ">" . substr($key, 0, 59);}
        else {
            $HeadForAli  = ">" . $key; 
            $HeadForAli .= " " x (59-$keyLen);
        }
        
        $suffixLen     = $structureLen - $prefixLen - length($tmpSeq);
        $suffixIndex   = $prefixLen + length($tmpSeq);
        
        my $posAdjustLeft  = $dir eq "FW"
                            ? -$prefixLen
                            : -$suffixLen;
        my $posAdjustRight = $dir eq "FW"
                            ? $suffixLen
                            : $prefixLen;
		
        $HeadForAli .= sprintf(" %s %6s:%6s %10s %s\n",
                        $dir,
                        $start + $posAdjustLeft,
                        $stop  + $posAdjustRight,
                        $evalue,
                        $DATAFILE);
		
        $res_ali .= $HeadForAli;
        
        # If we need to print out the header sequence
        my $headSeq;
        my $tailSeq;
        my $AliSeq = "";
        if($prefixLen > 0) {
            if($dir eq "RC") { 
            # We need to reverse-complement the original sequence
                if(($prefixLen + $stop) < length($seq)) {
                    $headSeq = substr($seq, $stop, $prefixLen);
                    $headSeq = reverse($headSeq);
                    $headSeq =~ tr/ACGTacgt/TGCAtgca/;
                }
                elsif($stop < length($seq)) {
                    $headSeq = "n" x ($prefixLen - (length($seq) - $stop));
                    my $tmp = reverse(substr($seq, $stop , $prefixLen));
                    $tmp =~ tr/ACGTacgt/TGCAtgca/;
                    $headSeq .= $tmp;
                }
                else {
                    $headSeq =  "n" x $prefixLen;
                }
            }
            else {
                if(($start - $prefixIndex) > 0) {
                    $headSeq =  substr($seq, ($start - $prefixIndex - 1), ($prefixLen));
                }
                elsif($start > 0 ) {
                    $headSeq  = "n" x ($prefixLen - $start + 1);
                    $headSeq .=  substr($seq, 0, $start - 1);
                }
                else {
                    $headSeq =  "n" x $prefixLen;
                }
            }
            $AliSeq .= $headSeq if $headSeq;
            print $key . "\n" if $DEBUG;
        }
        $AliSeq .= &modifyModelSeq($tmpSeq, $structure, $prefixLen, $erpinMaskNums);
        
        # If we need to print out the tail sequence
        if($suffixLen > 0) {
            if($dir  eq "RC") {
                # We need to reverse-complement the original sequence
                $suffixIndex   = $start - $suffixLen;
                
                if($suffixIndex > 0) {
                    $tailSeq = substr($seq, ($suffixIndex - 1), $suffixLen);
                    $tailSeq = reverse($tailSeq);
                    $tailSeq =~ tr/ACGTacgt/TGCAtgca/;
                }
                elsif ($start < length($seq)) {
                    if ($suffixIndex >= 0) {
                    $tailSeq  = substr(reverse($seq), (length($seq) - ($suffixLen + $suffixIndex) + 1), ($suffixLen + $suffixIndex));
                    $tailSeq  =~ tr/ACGTacgt/TGCAtgca/;
                    $tailSeq .= "n" x (($suffixIndex * -1) +1);
                    }
                }
                else {
                    $tailSeq =  "n" x $suffixLen;
                }
            }
			else {
				# We need to print out a pending sequence
				my $len = $stop;
				
				if(($suffixLen + $len) <= length($seq)) {
					$tailSeq = substr($seq, $stop, $suffixLen);
				}
				elsif($stop < length($seq)) {
					$tailSeq  = substr($seq, $stop, $suffixLen);
					$tailSeq .= "n" x ($suffixLen - (length($seq) - $stop));
				}
				else {
					$tailSeq =  "n" x $suffixLen;
				}
			}
            $AliSeq .= $tailSeq if $tailSeq;
		}
        $res_ali .= $AliSeq."\n";
        
        my $Alignment = new PirObject::erpinAlignement(
                        header     => $key,
                        aliNumber  => $aliNumber,
                        strand     => $dir,
                        AliStart   => $start + $posAdjustLeft,
                        AliStop    => $stop  + $posAdjustRight,
                        LogStart   => $start,
                        LogStop    => $stop,
                        evalue     => $evalue,
                        AliForAli  => $AliSeq,
                        AliForLog  => $reportSeq,
                        HeadForAli => $HeadForAli,
                        HeadForLog => $HeadForLog,
                        );
       push(@$Alignments,$Alignment);
    }
    
    open(OUTMODELLOG, ">$modelLogFile") or die "Could not open training set logfile\n";
    open(OUTMODEL, ">$outputModel") or die "Could not open new training set file\n";
    print OUTMODEL    $res_ali;
    print OUTMODELLOG $res_log;
    close OUTMODEL;
    close OUTMODELLOG;
    
    # Complete ErpinResult with general fields
    $ErpinResult->set_structure($structure);
    $ErpinResult->set_bracket($BracketModel);
    $ErpinResult->set_consensus($consensus);
    $ErpinResult->set_structureLen($structureLen);
    $ErpinResult->set_SequenceLen($lenSeq);
    $ErpinResult->set_fileName($DATAFILE);
    $ErpinResult->set_Alignments($Alignments);
    
    return ($ErpinResult);
}
 
sub GetConsensus {
    my $modelFile = shift;
    
    my $LinStructMod  = PirObject::LinStruct->new();
    my $align_fh      = new IO::File "<$modelFile"
    or die "Cannot reread aligned output '$modelFile': $!\n";
    $LinStructMod->ImportFromMultipleAlignment($align_fh); # will close the filehandle
    
    my $consensus = $LinStructMod->multalign()->get_consensus;
    return $consensus;
}

############################
## WARNING => INFORMATION ##
############################
#AFTER THIS LINE, FOLLOWING FUNCTION DO NOT USE GLOBAL VARIABLES ANYMORE

# Get sequences from erpin output file
sub GetSeqFromOutputFile {
	my $lowerPerCutOff  = shift;
	my $upperPerCutOff  = shift;
	my $Rdata           = shift;
	
	#locals variable
	my $header = "";
	my $Rseqs           = {};
	my @eValueOrder;
	my @originalOrder;
	my %dir             = ();
	my %start           = ();
	my %end             = ();
	my %eValue          = ();
	my %reverseKey      = ();
	my $arrayCounter    = 0; 
	my $countera        = 0;
	my $counterb        = 0;
	
	foreach my $line (@$Rdata) 	{
		chomp($line);
        
		if($line =~ m/>(.*)/) {
            $arrayCounter = 0 if $1 ne (defined($header) ? $header : "");
            $header = $1;
            $header =~ s/\cM//;
            next;
		}
		elsif(!defined($header)) { next; }
		elsif($line =~ m/(FW|RC)\s+(\d+)\s+(-*[\d]+)\.\.([\d]+)\s+([\d\.]+)\s+([\d\.e\-\+]+)$/) { 
			# FW   1     825..948      109.15  1.46e-36
			$countera++;
			push @{$dir{$header}},      $1;
			push @{$start{$header}},    $3;
			push @{$end{$header}},      $4;
			
			if( defined( $reverseKey{"$arrayCounter<->$1<->$header"} ) ) {
				print YELLOW "DEBUG $countera: $arrayCounter<->$1<->$header has already been entered!\n";
			}
			else {
				$reverseKey{"$arrayCounter<->$1<->$header"}  = $6;
				if($DEBUG) {
					print YELLOW "DEBUG $countera: $arrayCounter<->$1<->$header- $6\n";
				}
			}
			
			push @originalOrder, "$arrayCounter<->$1<->$header";
			push @{$eValue{$header}},   $6;
			$arrayCounter++;
			next;
		}
		#22
		elsif(defined($header) and $line =~ /^$/){ $header = undef; next; }
		else { push @{$Rseqs->{$header}}, $line; }
	}
	
	# We must sort the order of the sequences by e-value
	foreach my $key (sort{$reverseKey{$a} <=> $reverseKey{$b}} keys %reverseKey) {
		$counterb++;
		push @eValueOrder, $key;
	}
	
	my $numberResults = @eValueOrder;
	my $first = int( ( (100 - $upperPerCutOff) / 100 ) * $numberResults);
	my $last = int( ( (100 - $lowerPerCutOff) / 100 ) * $numberResults);
	@eValueOrder = @eValueOrder[$first..($last-1)];
	
	if($DEBUG) {
		print YELLOW "DEBUG COUNTER IS $countera\n";
		print YELLOW "DEBUG COUNTER IS $counterb\n";
		print YELLOW "DEBUG: seqs size          = " . keys(%$Rseqs) . "\n";
		print YELLOW "DEBUG: reverseKey size    = " . keys(%reverseKey) . "\n";
		print YELLOW "DEBUG: eValueOrder size   = " . scalar(@eValueOrder) . "\n";
		print YELLOW "DEBUG: originalOrder size = " . scalar(@originalOrder) . "\n";
		print YELLOW "DEBUG: dir size           = " . keys(%dir) . "\n";
		print YELLOW "DEBUG: start size         = " . keys(%start) . "\n";
		print YELLOW "DEBUG: end size           = " . keys(%end) . "\n";
		print YELLOW "DEBUG: evalue size        = " . keys(%eValue) . "\n";
	}
	return($Rseqs, \@eValueOrder, \@originalOrder, \%dir, \%start, \%end, \%eValue, $first, $last, $numberResults);
}

# Get structure lines from a model file
sub GetStructureFromModelFile {
	#get the model
	my $Rmodel = shift;
	
	#local vars
	my $header;
	my $structure;
	
	foreach my $line (@$Rmodel) {
		if($line =~ m/>.*/) {
			if($line =~ m/>structure/) {
				$header = $1;
				next;
			}
			else { last; }
		}
		else {
			if(!defined($structure)) {
				$structure = $line;
			}
			else {
				$structure .= $line;
			}
		}
	}
	return $structure; 
}
 
sub GetStructurePos {
	my $structure = shift;
	my $pos       = shift;
	
	if ($pos > 99) { die "You can't have a mask position that is greater than 99!\n"; }
	
	my $pos1      = int($pos/10);
	my $pos2      = int($pos%10);
	my ($struct1, $struct2) = split /\n/, $structure;
	my $posA      = index($struct1, $pos1);
	my $posB      = index($struct2, $pos2, $posA);
  
	return $posB;
}

# Get length of the structure line
sub GetStructureLength {
	my $structure = shift;
	my ($struct1, $struct2) = split /\n/, $structure;
	return length($struct2);
}
 
sub makeReportSeq {
	my $inSeq     = shift;
	my @maxBitLen = @_;
	my $outSeq    = "";
	my @seqBits   = split(/\./, $inSeq);
	
	for(my $i=0; $i<@seqBits;$i++) {
		if($seqBits[$i] =~ m/^[\-]+$/) {
			if($maxBitLen[$i] > 16) {
				$outSeq .= " " x 17;
			}
			else {
				$outSeq .= " " x ($maxBitLen[$i] + 1);
			}
		}
		#If this is lowercase
		elsif($seqBits[$i] =~ m/[a-z]/) {
			$seqBits[$i] =~ s/-//g;
			my $lengthSeqBits = length($seqBits[$i]);
			
			if($lengthSeqBits > 16) {
				$outSeq .= substr($seqBits[$i], 0, 3);
				
				if($lengthSeqBits/1000 >= 1) {
					$outSeq .= "..(" . $lengthSeqBits  . ").." .  substr($seqBits[$i], $lengthSeqBits - 3, 3) . " ";
				}
				elsif(($lengthSeqBits/100) >= 1) {
					$outSeq .= "..(" . $lengthSeqBits  . ")..." . substr($seqBits[$i], $lengthSeqBits - 3, 3) . " ";
				}
				else {
					$outSeq .= "...(" . $lengthSeqBits  . ")..." .substr($seqBits[$i], $lengthSeqBits - 3, 3) . " ";
				}
			}
			else {
				my $filler;
				if($maxBitLen[$i] > 16) {
					$filler = 16 - $lengthSeqBits;
				}
				else {
					$filler = $maxBitLen[$i] - $lengthSeqBits;
				}
				$outSeq .= $seqBits[$i] . " " . " " x $filler;
			}
		}
		else {
			$outSeq .= $seqBits[$i] . " ";
		}
	}
	return $outSeq;
}
 
sub modifyModelSeq {
  my $model               = shift;
  my ($struct1, $struct2) = split("\n", shift);
  my $prefixLen           = shift;
  my $erpinMaskNums       = shift; # array ref

  my %masked = map { int($_ + 0) => 1 } @$erpinMaskNums;

  my @structs = (); # will contain { DOMAIN, LEN, MODELSUBS } for each substruct of the structure
  my $prevdomain = "";
  my $blocknum=-1; # will immediately increase to 0 in next loop
  for (my $i=0;$i<length($model);$i++) {
      my $domain = substr($struct1,$i+$prefixLen,1) . substr($struct2,$i+$prefixLen,1); # "01", "02" ... "99".
      $blocknum++ if $domain ne $prevdomain;
      $structs[$blocknum] ||= { "DOMAIN" => $domain, "LEN" => 0, "MODEL" => "" };
      $structs[$blocknum]->{"LEN"}++;
      $prevdomain=$domain;
  }

  my $tmp = $model; # destructively split
  foreach my $substr (@structs) {
      my $blocklen = $substr->{"LEN"};
      $substr->{"MODEL"} = substr($tmp,0,$blocklen); # first $blocklen chars
      $tmp = substr($tmp,$blocklen); # reminder
  }

  foreach my $substr (@structs) {
      my $domain = $substr->{"DOMAIN"};
      my $len    = $substr->{"LEN"};
      my $model  = $substr->{"MODEL"};
      $substr->{"NEWMODEL"} = $model; # by default, unchanged.

      my $domAsInt = int($domain + 0);
      next if exists($masked{$domAsInt}); # leave unchanged if not selected in ERPIN args

      my $nodash     = $model;
      $nodash        =~ s/-+//g;
      my $numdash    = length($model)-length($nodash);
      my $beforedash = substr($nodash,0,int(length($nodash)/2)); # first half
      my $afterdash  = substr($nodash,length($beforedash));      # second half
      my $newmodel   = $beforedash . ("-" x $numdash) . $afterdash;
      $substr->{"NEWMODEL"} = $newmodel;
  }

  my $newmodel = "";
  foreach my $substr (@structs) {
      $newmodel .= $substr->{"NEWMODEL"};
  }
  $newmodel;
}

sub MakeLogBrackets {
    my $StructureLines = shift;
    my $MaxLengths     = shift; # ref to array of max sizes for all elements (each <= to StructL)
    my $ErpinMaskNums  = shift; # ref to array of selected elements

    my ($struct1, $struct2) = split("\n", $StructureLines);
    my %masked = map { int($_ + 0) => 1 } @$ErpinMaskNums;

    my @structs = (); # will contain { ELEMID, LEN, MAXLEN, SYM } for each element of the structure
    my $prevElemID = "";
    my $elemnum=-1; # will immediately increase to 0 in next loop
    for (my $i=0;$i<length($struct1);$i++) {
        my $ElemID = substr($struct1,$i,1) . substr($struct2,$i,1); # "01", "02" ... "99".
        $elemnum++ if $ElemID ne $prevElemID;
        $structs[$elemnum] ||= { "ELEMID" => $ElemID, "LEN" => 0,  };
        $structs[$elemnum]->{"LEN"}++;
        $prevElemID=$ElemID;
    }

    # the @$MaxLengths array is in same order as structure elements;
    # however the entries start at an offset with respect to the full struct.
    my @sortedEMN = sort { $a <=> $b } @$ErpinMaskNums;
    my $minElem = $sortedEMN[0];
    my $offset = undef;
    for (my $n=0;$n<@structs;$n++) {
        my $struct = $structs[$n];
        my $elemID = $struct->{"ELEMID"};
        next if int($elemID+0) != $minElem;
        $offset = $n;
        last;
    }
    die "Cannot find element #$minElem in structure?\nStruct:\n$StructureLines"
        unless defined($offset);
    for (my $n=0;$n<@$MaxLengths;$n++) {
        my $max = $MaxLengths->[$n];
        $structs[$n+$offset]->{"MAXLEN"} = $max;
    }

    # Identify the selected elements and sets what characters to display
    # for the bracket expression.
    my %seenID = ();
    for (my $n=0;$n<@structs;$n++) {
        my $struct = $structs[$n];
        my $elemID = $struct->{"ELEMID"};
        if ($masked{int($elemID + 0)}) {
            $struct->{"SELECTED"}="YES";  # Right now it's not used.
        }
        if (exists $seenID{$elemID}) {
            $seenID{$elemID}->{"SYM"} = "[";
            $struct->{"SYM"}          = "]";
        } else {
            $struct->{"SYM"}          = " ";
            $seenID{$elemID} = $struct; # remember it for future use (for [ and ] maybe)
        }
    }

    # Ok, we have all the info, create the bracket line.
    my $brackets = "";
    for (my $n=0;$n<@structs;$n++) {
        my $struct = $structs[$n];
        next unless exists $struct->{"MAXLEN"}; # we only show some elems
        my $maxlen   = $struct->{"MAXLEN"};
        my $sym      = $struct->{"SYM"} || "?";
        my $selected = $struct->{"SELECTED"};
        $brackets .= " " if $brackets ne "";
        if ($selected) {
            $brackets .= $sym x $maxlen;
        } else {
            $brackets .= $sym x ($maxlen < 16 ? $maxlen : 16);
        }
    }
    return $brackets;
}

sub CreateSeq {
    my $LinStruct     = shift;
    my $seq           = shift;
    my $erpinMaskNums = shift;

    return $seq if  $seq =~ /^\d+$/;
    my $Interest_seq = "";
    my $each_nt   = [split(//,$seq)];
    my $elemIndex   = $LinStruct->get_idsByPos();
    my $erpin_number = {};
    foreach my $number (@$erpinMaskNums) { $erpin_number->{ $number }++;  }
    for (my $i = 0;  $i < (@$each_nt-1); $i++) {
        my $nt = $each_nt->[$i];
        my $id = int($elemIndex->{$i});
        $Interest_seq .= $nt if $erpin_number->{$id};
    }
    return $Interest_seq;
}

# Erpin error when no results
sub noErpinResultError {
	print RED "****************************************\n";
	print RED "*  There was a problem running Erpin   *\n";
	print RED "*     It did not produce an output     *\n";
	print RED "* Run Erpin directly for error messages*\n";
	print RED "****************************************\n"; 
	exit(1);
}

#########################
#  For tRNA prediction  #
#########################

sub DefineCodonTable {
    my $GENETICCODE = shift;
    
    while () {
       last if $GENETICCODE;
       print "No genetic code has been specified, which genetic code do you want to use ? 
       (ncbi genetic code accepted, example 1 for standard genetic code)\n";
       $GENETICCODE = <STDIN>;
       last if $GENETICCODE =~ m/^\d+$/;
    }
    
    $CODON_TABLE = Bio::Tools::CodonTable->new( -id => $GENETICCODE )
        or die "Cannot find codon table for genetic code id '$GENETICCODE' ?!?\n";
}

sub AddAcInfo {
    my ($AliFile,$ac_ID,$erpinResult) = @_;
    
    my $linstruct  = PirObject::LinStruct->new();
    my $align_fh   = new IO::File "<$AliFile"
        or die "Cannot reread aligned output '$AliFile': $!\n";
    $linstruct->ImportFromMultipleAlignment($align_fh); # will close the filehandle
    
    my $length_ali  = $linstruct->get_structlength(); # full width, including gaps
    my $elemIndex   = $linstruct->get_elemsByIds();   # hash to locate info for each elem
    my $ac_elem     = $elemIndex->{"$ac_ID"}          # the element for the anticodon
        or die "Cannot find element '$ac_ID' for anticodon in structure?!?\n";
    my $ac_offset   = $ac_elem->get_startposL();
    my $rac_offset  = $length_ali-$ac_offset-3;  # reverse offset
    
    my $elem_len =  $ac_elem->get_elemLength();
    die "The element '$ac_ID' is $elem_len nt long, it can not match the anticodon\n" if $elem_len != 3;
    
    my $Alignments = $erpinResult->get_Alignments();
    foreach my $Alignment (@$Alignments) {
        my $AliForAli = $Alignment->get_AliForAli();
        
        # Define Amino Acid
        my $ac = uc substr($AliForAli,$ac_offset,3);   # anticodon
        my $codon = $ac;                               # codon as used in protein
        $codon = reverse $codon;
        $codon =~ tr/UTCGA/AAGCT/;
        my $aa = $CODON_TABLE->translate($codon) || "X";
        
        # Define Anticodon position
        my $strand = $Alignment->get_strand();
        my ($tRNA_begin,$tRNA_end) = ($Alignment->get_AliStart(),$Alignment->get_AliStop());
        my $begin_ac = 0;
        if ($strand eq "FW") {
            my $seq_before_ac  =  substr($AliForAli,0,$ac_offset);
               $seq_before_ac  =~ s/-+//g;
               $begin_ac       = $tRNA_begin + length($seq_before_ac);
               $tRNA_end       = $tRNA_end;
        }

        if ($strand eq "RC") {
            my $revseq        = reverse $AliForAli;
            my $seq_before_ac = substr($revseq,0,$rac_offset);
            $seq_before_ac    =~ s/-+//g;
            $begin_ac         = $tRNA_begin + length($seq_before_ac);
        }
        
        $Alignment->set_AcStart($begin_ac);
        $Alignment->set_AcStop($begin_ac+2);
        $Alignment->set_AcAa($aa);
        $Alignment->set_AcTriNt($ac);
        
        next if $aa ne "H";
        # 1 bp adjustment at 3' for Histidines
        $tRNA_begin-- if $strand eq "FW";
        $tRNA_end++   if $strand eq "RC";
        $Alignment->set_AliStart($tRNA_begin) if $strand eq "FW";
        $Alignment->set_AliStop($tRNA_end)    if $strand eq "RC";
    }
}

#########################
#  For Result Selection #
#########################

sub SelectResult {
    my $AllErpinResult = shift;
    print "\nSelect best results for overlapping matches.\n";
    # Make results selection 
    foreach my $block_num (keys %$AllErpinResult) {
        my $bl_name_block = $AllErpinResult->{$block_num};
        my $block = $bl_name_block->[1];
        next if scalar(@$block) <= 1;
        &RemoveAlignment($block);
    }
}

sub RemoveAlignment {
    my $block = shift;
    
    for(my $i = 0; $i < scalar(@$block); $i++) {
        my $sub_block_i = $block->[$i];
        my $label_i     = $sub_block_i->get_Label();
        my $ali_block_i = $sub_block_i->get_Alignments();
        
        # Reverse loop on ali_block i
        for (my $i_ali = @$ali_block_i-1 ; $i_ali >= 0 ; $i_ali--) {
            my $ali_i = $ali_block_i->[$i_ali];
            my ($start_i,$stop_i,$evalue_i) =
               ($ali_i->get_LogStart(),$ali_i->get_LogStop(),$ali_i->get_evalue());
            ($start_i, $stop_i) = ($stop_i, $start_i) if $stop_i < $start_i;
            my $delete_i     = 0;
            
            for(my $j = $i+1; $j < scalar(@$block); $j++) {
                my $sub_block_j = $block->[$j];
                my $label_j     = $sub_block_j->get_Label();
                my $cp_sub_block_i = $sub_block_i->DeepClone();
                my $mod_block_i = $cp_sub_block_i->get_modTab();
                
                my $cp_sub_block_j = $sub_block_j->DeepClone();
                my $mod_block_j = $cp_sub_block_j->get_modTab();
                # Treat modular case
                my ($iInj,$jIni,$iIsj) = &CompareModBlock($mod_block_i,$mod_block_j) if (@$mod_block_i) != 0;
                # Specially for non modular case
                $iIsj = 1 if (@$mod_block_i) = 0;
                next if !$iInj && !$jIni && !$iIsj;
                
                my $ali_block_j  = $sub_block_j->get_Alignments();
                
                # Reverse loop on ali_block j
                for (my $j_ali = @$ali_block_j-1 ; $j_ali >= 0 ; $j_ali--) {
                    next if $delete_i == 1;
                    my $ali_j = $ali_block_j->[$j_ali];
                    
                    my $head_i = $ali_i->get_header();
                    my $head_j = $ali_j->get_header();
                    my $headL_i = $ali_i->get_HeadForLog();
                    my $headL_j = $ali_j->get_HeadForLog();
                    next if $head_i ne $head_j;
                    
                    my ($start_j,$stop_j,$evalue_j) =
                       ($ali_j->get_LogStart(),$ali_j->get_LogStop(),$ali_j->get_evalue());
                    ($start_j, $stop_j) = ($stop_j, $start_j) if $stop_j < $start_j;
                    my $seqLen = $sub_block_j->get_SequenceLen();
                    my $isOv = &OverlappingRegions($seqLen,$start_i,$stop_i,">",$start_j,$stop_j,">");
                    next if !$isOv;
                    if ($iIsj == 1) {
                        $evalue_i = "1e-100" if $evalue_i =~ m/^([\+\-]?)([\d\.]*)(?:e([\-]?00))?$/x;
                        $evalue_j = "1e-100" if $evalue_j =~ m/^([\+\-]?)([\d\.]*)(?:e([\-]?00))?$/x;
                        my $iHaveBetterEvalue =  &CompareHighPrecisionFloats($evalue_i,$evalue_j) == -1  ? 1 : 0;
                        # Keep result with better evalue
                        splice(@$ali_block_i, $i_ali, 1) if $iHaveBetterEvalue == 0; # splice i
                        $delete_i = 1 if $iHaveBetterEvalue == 0;
                        splice(@$ali_block_j, $j_ali, 1) if $iHaveBetterEvalue == 1; # splice j
                    }
                    else {
                        # Keep result with better evalue
                        splice(@$ali_block_i, $i_ali, 1) if $iInj; # splice i
                        $delete_i = 1 if $iInj;
                        splice(@$ali_block_j, $j_ali, 1) if $jIni; # splice j
                    }
                }
                @$ali_block_j ? $sub_block_j->set_Alignments([@$ali_block_j])
                          : $sub_block_j->set_Alignments([]) ;
            }
        }
        @$ali_block_i ? $sub_block_i->set_Alignments([@$ali_block_i])
                              : $sub_block_i->set_Alignments([]) ;
    }
}

sub CompareModBlock {
    my ($cp_arrayI,$cp_arrayJ) = @_;
    
    my ($count1,$count2) = ({},{});
    foreach my $element (@$cp_arrayI) { $count1->{$element}++ }
    foreach my $element (@$cp_arrayJ) { $count2->{$element}++ }
    
    # Treat array 1
    #foreach my $element (@$cp_arrayJ) { $count2->{$element}++ }
    for (my $i = @$cp_arrayI-1 ; $i >= 0 ; $i--) {
        my $i_val = $cp_arrayI->[$i];
        splice(@$cp_arrayI, $i, 1) if  defined($count2->{$i_val});
    }
    
    # Treat array 2
    for (my $j = @$cp_arrayJ-1 ; $j >= 0 ; $j--) {
        my $j_val = $cp_arrayJ->[$j];
        splice(@$cp_arrayJ, $j, 1) if defined($count1->{$j_val});
    }

    my $array_IinJ = scalar(@$cp_arrayI) == 0 ? 1 : 0 ;
    my $array_JinI = scalar(@$cp_arrayJ) == 0 ? 1 : 0 ;
    my $array_IisJ = scalar(@$cp_arrayI) == 0 && scalar(@$cp_arrayJ) == 0 ? 1 : 0;
    return($array_IinJ,$array_JinI,$array_IisJ);
}

sub OverlappingRegions {
    # Works even for circular genomes and regions that span the gap
    my ($seqlen,$start1,$end1,$dir1,$start2,$end2,$dir2) = @_;

    my $spansgap1 = (($dir1 =~ m#>#) xor ($start1 <= $end1)); # true means spans the gap
    my $spansgap2 = (($dir2 =~ m#>#) xor ($start2 <= $end2)); # true means spans the gap

    if ($spansgap1) {
        if ($dir1 =~ m#>#) {
            $end1 += $seqlen;
        }
        else {
            $start1 += $seqlen;
        }
    }

    if ($spansgap2) {
        if ($dir2 =~ m#>#) {
            $end2 += $seqlen;
        }
        else {
            $start2 += $seqlen;
        }
    }

    ($start1,$end1) = ($end1,$start1) if $start1 > $end1;
    ($start2,$end2) = ($end2,$start2) if $start2 > $end2;

    # Test for overlap
    return 1 if ! ($end1 < $start2 || $start1 > $end2);
    return 0 if $spansgap1 == $spansgap2; # same spanning sit -> we're done

    if (! $spansgap1) {
        $start1 += $seqlen;
        $end1   += $seqlen;
    }

    if (! $spansgap2) {
        $start2 += $seqlen;
        $end2   += $seqlen;
    }

    # Test for overlap again, new situation
    return 1 if ! ($end1 < $start2 || $start1 > $end2);
    return 0; # really, no overlap
} # End sub

sub CompareHighPrecisionFloats {
    # Only for floats that are in NORMALIZED scientific form.
    # Examples of different cases :
    #
    #    1       1.      1.2
    #    1.2e    1.2e3   1.2e-3
    #    e-3     1e3
    #
    # Each of these can optionally be prefixed with "+" or "-".
    #
    # Unlike Math::BigFloat, this routine handles "e-3".

    my ($x,$y) = @_;

    die "Unparsable number '$x'\n"
        unless $x =~ m/^([\+\-]?)             # sign
                        ([\d\.]*)             # significand
                        (?:e([\+\-]?\d*))?         # exponent
                        $/x;
    my ($xsig,$xman,$xexp) = ($1,$2,$3);

    die "Unparsable number '$y'\n"
        unless $y =~ m/^([\+\-]?)             # sign
                        ([\d\.]*)             # significand
                        (?:e([\+\-]?\d*))?         # exponent
                        $/x;
    my ($ysig,$yman,$yexp) = ($1,$2,$3);

    # Define missing optional components of number representation
    $xsig ||= "+";
    $ysig ||= "+";
    $xman = 1 if !defined($xman) || $xman eq "";
    $yman = 1 if !defined($yman) || $yman eq "";
    $xexp = 0 if !defined($xexp) || $xexp eq "";
    $yexp = 0 if !defined($yexp) || $yexp eq "";

    # Compare numbers when $x or $y are effectively zero
    return 0
        if $xman == 0 && $yman == 0;  # $x == 0 and $y == 0
    return ($xsig eq '-' ? -1 : +1)
        if $xman != 0 && $yman == 0;  # $x != 0 and $y == 0
    return ($ysig eq '-' ? +1 : -1)
        if $xman == 0 && $yman != 0;  # $x == 0 and $y != 0

    # Easy comparisons when signs differ
    if ($xsig ne $ysig) {
        return $xsig eq '+' ? 1 : -1;
    }

    # Permutate X <=> Y if both signs are negative
    ($xman,$xexp,$yman,$yexp) = ($yman,$yexp,$xman,$xexp)
        if $xsig eq '-'; # $ysig is '-' too at this point.

    # At this point, $x and $y both have mantissas > 0
    return ($xexp <=> $yexp) if $xexp != $yexp;  # $x and $y have different EXP, so compare EXP
    return ($xman <=> $yman);                    # $x and $y have same EXP, so compare mantissas
}

################
#  For Output  #
################

sub CreateRNAPredictions {
    my $AllResult = shift;
    
    my $filename = basename($DATAFILE);
    my $aliFile = "$TMP_DIR/$filename.ali.tmp";
    my $logFile = "$TMP_DIR/$filename.log.tmp";
    my $csmFile = "$TMP_DIR/$filename.csm.tmp";
    my $xmlFile = "$TMP_DIR/$filename.xml.tmp";
    my $apcFile = "$TMP_DIR/$filename.apc.tmp";

    
    open (ALIFILE, ">>$aliFile")
        or die "Can't write to .ali.tmp file '$aliFile': $!\n";
    open (LOGFILE, ">>$logFile")
        or die "Can't write to .log.tmp file '$logFile': $!\n";
    open (CSMFILE, ">>$csmFile")
        or die "Can't write to .csm.tmp file '$csmFile': $!\n";

    # Treat .ali.tmp .log.tmp and .ali.tmp .csm.tmp
    my ($ali_str,$log_str,$csm_str) = ("","","");
    my $AllRNAPred = [];
    my $AllRNAPredictionList = [];
    my $nbTotRes   = 0;
    
    my ($short_summary,$screen_summary,$mail_summary) = &CreateSummary($AllResult);
    my ($RNA_summary,$ali_summary,$log_summary) = ("","","");
    
    foreach my $res_num (sort keys %$AllResult) {
        my $erpin_res  = $AllResult->{$res_num}; 
        my $block_name = $erpin_res->[0];
        my $block      = $erpin_res->[1];
        for(my $i = 0; $i < scalar(@$block); $i++) {
            my $sub_block   = $block->[$i];
            my $Alignments  = $sub_block->get_Alignments();
            my $nb_ali      = scalar(@$Alignments);
            next if $nb_ali == 0;
            my $numItem     = $sub_block->get_NumItem();
            my $label       = $sub_block->get_Label();
            my $bracket     = $sub_block->get_bracket();
            my $structure   = $sub_block->get_structure();
            my $consensus   = $sub_block->get_consensus();
            my $comment     = $sub_block->get_comment();
            
            my $takeAliCoord  = 0; 
            $takeAliCoord  = 1 if $comment =~ m/rns/ && $comment =~ m/complete/;
            $takeAliCoord  = 3 if $comment =~ m/rns/ && $comment =~ m/3/;
            $takeAliCoord  = 5 if $comment =~ m/rns/ && $comment =~ m/5/;
            
            my $RNAPredictionList = PirObject::RNAPredictionList->new();
            
            my ($aliString1,$rnaString,$aliString2,$logString,$csmString)
                = CreateHeadString($block_name,$numItem,$nb_ali,$label,$comment,$structure,$consensus,$bracket,$i,$takeAliCoord);
            
            my $predictlist = [];
            my $aliString3  = ""; #just to advance
            ($predictlist,$rnaString,$aliString3,$logString,$csmString) 
                = &AddInfoForeachAli($Alignments,$aliString3,$rnaString,$logString,$csmString,$block_name,$comment,$takeAliCoord);
            
            $RNA_summary .= $rnaString;
            my $aliString = $aliString1.$aliString2.$aliString3;
            $ali_str .= "\n$aliString";
            $log_str .= "\n$logString";
            $csm_str .= "\n$csmString";
                        
            $RNAPredictionList->set_Name($block_name);
            $RNAPredictionList->set_NumItem($numItem);
            $RNAPredictionList->set_Label($label) if $label;
            $RNAPredictionList->set_rnapredictions($predictlist);
            push(@$AllRNAPred, $RNAPredictionList);
        }
    }
    
    $ali_summary = $ali_str;
    $ali_str  = "$short_summary\n\n";
    $ali_str .= "$RNA_summary\n" if ($RNA_summary);
    $ali_str .= $ali_summary;
    
    $log_summary = $log_str;
    $log_str  = "$short_summary\n\n";
    $log_str .= "$RNA_summary\n" if ($RNA_summary);
    $log_str .= $log_summary;
    
    print ALIFILE "$ali_str" if $ali_str;
    print LOGFILE "$log_str" if $log_str;
    print CSMFILE "$csm_str" if $csm_str;
    
    &CreateAPCFile($AllRNAPred,$apcFile);
    
    # Treat XML File.
    my $outfh = new IO::File ">$xmlFile"
        or die "Can't write to .xml file '$xmlFile': $!\n";
    foreach my $predList (@$AllRNAPred) {
        print $outfh PirObject::RNAPredictionList->ObjectXMLDocumentHeader();
        $predList->ObjectToFileHandle($outfh);
    }
    
    $outfh->close();
    close (ALIFILE);
    close (LOGFILE);
    close (CSMFILE);
    
    &CopyResults($aliFile,$logFile,$csmFile,$xmlFile,$apcFile) if !$MAIL_ADR;
    return ($short_summary,$screen_summary,$mail_summary);
}

sub CreateSummary {
    my $AllResult = shift;
    
    my ($short_summary,$screen_summary,$mail_summary) = ("","","");
    
    my $filename = basename($DATAFILE);
    
    my $nbTotRes   = 0;
    
    $screen_summary .= sprintf("\n%-30s %15s %15s \n%-30s %15s %15s", "","Initial #","Retained #","","of solution","of solution");
    my $mail_pre = "<PRE><FONT face='courier' size=4>" if $MAIL_ADR;
    $short_summary .= sprintf("\n%-30s %15s \n%-30s %15s", "","Retained #","","of solution");
    
    foreach my $res_num (sort keys %$AllResult) {
        my $erpin_res  = $AllResult->{$res_num}; 
        my $block      = $erpin_res->[1];
        for(my $i = 0; $i < scalar(@$block); $i++) {
            my $sub_block  = $block->[$i];
            my $comment    = $sub_block->get_comment();
            my $nbOriSol   = $sub_block->get_OriSol();
            my $time       = $sub_block->get_time();
            my $Alignments = $sub_block->get_Alignments();
            my $nbRetSol   = scalar(@$Alignments);
            foreach my $ali (@$Alignments){
                my $header = $ali->get_header();
                $Ret_Rseqs->{$header}++;
            }
            $nbTotRes     += $nbRetSol if $comment =~ m/intron/;
            $nbOriSol = 0 if !$nbOriSol;
            $screen_summary .= sprintf("\n%-30.30s %15s %15s %15s", "$comment","$nbOriSol","$nbRetSol","$time");
            $short_summary   .= sprintf("\n%-30.30s %15s", "$comment","$nbRetSol");
        }
    }
    if ($nbTotRes != 0) {
        $screen_summary .= "\n------------------------------------------------------------------------------";
        $screen_summary .= sprintf("\n%-30s %15s %15s\n", "Total number of introns","","$nbTotRes");
        $short_summary  .= "\n----------------------------------------------";
        $short_summary  .= sprintf("\n%-30s %15s\n", "Total number of introns","$nbTotRes");
    }
    else {
        $screen_summary .= "\n";
        $short_summary .= "\n";
    }

    my $mail_suf  .= "</FONT></PRE>"if $MAIL_ADR;
    $mail_summary = $short_summary;
    $mail_summary =~ s/\n/<br>/;
    $mail_summary = $mail_pre.$mail_summary.$mail_suf if $MAIL_ADR;
    
    return ($short_summary,$screen_summary,$mail_summary);
}

sub CreateHeadString {
    my ($block_name,$numItem,$nb_ali,$label,$comment,$structure,$consensus,$bracket,$i,$takeAliCoord) = @_;
    
    my ($headString,$rnaString) = ("","");
    if (defined($MAIL_ADR)) {
        if ($i == 0) {
            $headString .=  "*************************************************\n";
            $headString .=  "Alignment for $block_name\n";
            $headString .=  "*************************************************\n\n";
            $headString .=  "$nb_ali matches for $comment\n\n";
        }
        else {
            $headString .=  "$nb_ali matches for $comment\n\n";
        }
    }
    else {
        $headString .=  "*************************************************\n";
        $headString .=  "Alignment for $block_name item $numItem\n";
        $headString .=  "*************************************************\n\n";
        $headString .=  "There are $nb_ali matches for $comment\n";
        $headString .=  "Processing label: $label\n" if defined $label;
        $headString .=  "\n";
    
    }
    
    my $aliString1 = $headString;
    
    my $aliString2 = ">structure\n$structure";
       $aliString2 .= ">consensus\n$consensus\n";
    
    my $logString = $headString;
    $logString =~ s/Alignment/Condensed alignment/;
    $logString .=  "Species name                       E-value   # of nt     Start..Stop      Str  #  Structure\n";
    $logString .=  "------------------------------  ---------- --------- -------------------- --- --- ------------------\n";
    $logString .=  "                                                                                 ";
    $logString .=  $bracket . "\n";
    
    if ($block_name =~ m/tRNA/i) {
        $rnaString .= "List of identified tRNAs prediction of complete structure, including discriminator position :\n\n";
        $rnaString .=  "                                               tRNA   tRNA tRNA  Anti  \n";
        $rnaString .=  "Species name                   tRNA # Strand  Begin    End Type Codon  E-value\n";
        $rnaString .=  "------------------------------ ------ ------ ------ ------ ---- ----- --------\n";
    }
    elsif ($takeAliCoord != 0) {
        $rnaString .= "List of identified $comment prediction of complete structure :\n\n";
        $rnaString .=  "                                                RNA    RNA\n";
        $rnaString .=  "Species name                    RNA # Strand  Begin    End             E-value\n";
        $rnaString .=  "------------------------------ ------ ------ ------ ------ ---- ----- --------\n";
    }
    
    my $csmString = $headString;
    $csmString =~ s/Alignment/Result/;

    return ($aliString1,$rnaString,$aliString2,$logString,$csmString);
}

sub AddInfoForeachAli {
    my ($Alignments,$aliString,$rnaString,$logString,$csmString,$block_name,$comment,$takeAliCoord) = @_;
    
    my $predictlist = [];
    my $count = 1;
    my $prev_head = "";
    foreach my $ali (@$Alignments) {
        my $RNAPrediction = PirObject::RNAPrediction->new();
        my $HeadForAli    = $ali->get_HeadForAli();
        my $AliForAli     = $ali->get_AliForAli();
        my @HeadForAli_elems = split(/ /,$HeadForAli);
        my $last_elem     = $HeadForAli_elems[-1];
        my @path_elems    = split(/\/+/,$last_elem);
        my $last_elem_path = $path_elems[-1];
        $HeadForAli       =~ s/$last_elem/$last_elem_path/;
        $aliString       .= "$HeadForAli"."$AliForAli\n";
        my $HeadForLog    = $ali->get_HeadForLog();
        my $AliForLog     = $ali->get_AliForLog();
        
        # Adjust Number and reverse start and stop if RC
        $HeadForLog =~ s/\|//;
        $HeadForLog =~ s/\.\./  /;
        my @HeadElem = split(/\s+/, $HeadForLog);
        $HeadForLog = sprintf ("%-30s| %10s %9s %9s..%-9s %s %3s ",
				$HeadElem[0],
				$HeadElem[1],
				$HeadElem[2],
				$HeadElem[5] eq 'FW' ? $HeadElem[3] : $HeadElem[4],
				$HeadElem[5] eq 'FW' ? $HeadElem[4] : $HeadElem[3],
				$HeadElem[5],
                $count);
        
        # Add blank line in order to separe contig
        $logString       .= $prev_head && $prev_head ne $HeadElem[0] ? 
                            "\n$HeadForLog"."$AliForLog\n" :
                            "$HeadForLog"."$AliForLog\n";
        $csmString       .= "------------------\n";
        
        my $RNA_num       = $ali->get_aliNumber();
        
        my $AcAa       = $ali->get_AcAa();
        if (defined($AcAa)) {
            $RNAPrediction->set_aacode($AcAa);
            $csmString .= "tRNA_AA:         $AcAa\n";
        }
        
        my $contigname = $ali->get_header();
        if (defined($contigname)) {
            $RNAPrediction->set_contigname($contigname);
            $csmString .= "Contigname:      $contigname\n";
        }
        
        my $strand     = $ali->get_strand();
        if (defined($strand)) { 
            my $sign     = ($strand eq "RC" ? "-" : "+");
            $RNAPrediction->set_strand($sign);
            $csmString .= "Strand:          $sign\n";
        }
        
        my $Start   = $block_name eq "tRNA" || $takeAliCoord == 1 || $takeAliCoord == 5
                     ? $ali->get_AliStart() : $ali->get_LogStart();
        if (defined($Start)) {
            $RNAPrediction->set_start($Start);
            $csmString .= "Start:           $Start\n";
        }
        
        my $Stop    = $block_name eq "tRNA" || $takeAliCoord == 1 || $takeAliCoord == 3 
                     ? $ali->get_AliStop() : $ali->get_LogStop();
        if (defined($Stop)) { 
            $RNAPrediction->set_stop($Stop);
            $csmString .= "Stop:            $Stop\n";
        }
        
        my $evalue     = $ali->get_evalue();
        if (defined($evalue)) {
            $RNAPrediction->set_evalue($evalue);
            $csmString .= "Evalue :         $evalue\n";
        }
        
        my $AcStart    = $ali->get_AcStart();
        if (defined($AcStart)) {
            $RNAPrediction->set_anticodon_start($AcStart);
            $csmString .= "Anticodon_start: $AcStart\n";
        }
        
        my $AcStop     = $ali->get_AcStop();
        if (defined($AcStop)) {
            $RNAPrediction->set_anticodon_stop($AcStop);
            $csmString .= "Anticodon_stop:  $AcStop\n";
        }
        
        my $AcSeq     = $ali->get_AcTriNt();
        if (defined($AcSeq)) {
            $RNAPrediction->set_anticodon_seq($AcSeq);
            $csmString .= "Anticodon_seq:   $AcSeq\n";
        }
        
        $csmString       .= "\n";
        ($Start,$Stop) = ($Stop,$Start) if $strand eq "RC";
        
        if ($rnaString) {
            $rnaString .= "\n" if $prev_head && $prev_head ne $HeadElem[0];
            my $short_cg_len = length($contigname) > 30 ? substr($contigname,0,30) : $contigname;
            my $Anti = $uniToThree{"$AcAa"} if $AcAa;
            $Start = "N.A" if $takeAliCoord == 3;
            $Stop  = "N.A" if $takeAliCoord == 5;
            $rnaString .= sprintf ("%-30s %6s %6s %6s %6s %4s %5s %s\n",
                    $short_cg_len,
                    $count,
                    $strand,
                    $Start,
                    $Stop,
                    $Anti  ||"",
                    $AcSeq ||"",
                    $evalue);
        }
        push(@$predictlist,$RNAPrediction);
        $prev_head = $HeadElem[0];
        $count++;
    }
    $rnaString .= "\n" if $rnaString;
    return ($predictlist,$rnaString,$aliString,$logString,$csmString);
}

sub CreateAPCFile {
    my ($AllRNAPred,$apcFile) = @_;

    open (APCFILE, ">>$apcFile")
        or die "Can't write to .ali.tmp file '$apcFile': $!\n";
        
    my $apcString = "";
    my $APC       = undef;
    my $annot_by_contig = {};
    my $combi = {};
    my $count = 0; 
    
    foreach my $predList (@$AllRNAPred) {
        my $name   = $predList->get_Name();
        my $label  = $predList->get_Label();
        my $rnapredictions = $predList->get_rnapredictions();
        
        foreach my $prediction (@$rnapredictions){
            my ($annot,$annot_ac) = &CreateAnnotPair($prediction,$name,$label);
            my $contig = $prediction->get_contigname();
            
            # Code hash in order to find contig name and genename
            my $annotpairs = undef;
            my $this_key = scalar(keys %$combi) == 0 ? 0 : undef ;
            $combi->{$this_key} = [$name,$contig] if defined($this_key) && $this_key == 0;
            my $contig_already_present = 0;
            
            
            while ( my ($key, $name_cgname) = each(%$combi) ) {
                if ($name_cgname->[0] eq $name && $name_cgname->[1] eq $contig ) {
                    $contig_already_present = 1;
                    $this_key   = $key;
                    $annotpairs = $annot_by_contig->{$key}
                }
            }
            if ($contig_already_present == 0) {
                $count++;
                $this_key = $count;
                $combi->{$this_key} = [$name,$contig]
            }
            
            push(@$annotpairs,$annot);
            push(@$annotpairs,$annot_ac) if $annot_ac;
            $annot_by_contig->{$this_key} = $annotpairs;
        }
    }
    
    while ( my ($key, $annotpairs) = each(%$annot_by_contig) ) {
        my $name_cgname = $combi->{$key};
        my ($name,$contig)   = ($name_cgname->[0],$name_cgname->[1]);
        $APC = new PirObject::AnnotPairCollection();
        $APC->set_genename($name);
        $APC->set_contigname($contig);
        $APC->set_annotpairlist($annotpairs);
        my $xml_APC = $APC->ObjectToXML();
        print APCFILE $xml_APC;
    }
    close (APCFILE);
}

sub CreateAnnotPair {
    my ($prediction,$name,$label) = @_;
    
    my $aacode          = $prediction->get_aacode();
    my $anticodon_seq   = $prediction->get_anticodon_seq() ;
    my $anticodon_start = $prediction->get_anticodon_start();
    my $anticodon_stop  = $prediction->get_anticodon_stop();
    my $contigname      = $prediction->get_contigname();
    my $evalue          = $prediction->get_evalue();
    my $start           = $prediction->get_start();
    my $stop            = $prediction->get_stop();
    my $strand          = $prediction->get_strand();
    
    my $arrow = $strand eq "+" ? "==>" : "<=="  ;
       ($start,$stop)        = ($stop,$start) if $strand eq "-";
    my ($startline,$endline) = ("","");
    
    if ($name =~ m/tRNA/i) {
        my $ac = lc($anticodon_seq);
           $ac =~ tr/t/u/;
        $name       = "trn$aacode";
        $startline  = ";     G-trn${aacode}\($ac\) $arrow start";
        $endline    = ";     G-trn${aacode}\($ac\) $arrow end";
    }
    elsif ($name =~ m/intron/i) {
        $startline  = ";; mfannot:     /group=$label";
        $endline    = ";; mfannot:";
        $name       = "comment";
    }
    else {
        $startline  = ";     G-$name $arrow start";
        $endline    = ";     G-$name $arrow end";
    }
    
    my $annot      = new PirObject::AnnotPair (
                         type      => "G", 
                         genename  => $name, 
                         startpos  => $start,
                         endpos    => $stop,
                         direction => $arrow,
                         startline => $startline,
                         endline   => $endline,
                         score     => $evalue,
                         idbyRNA   => 1
                         );
    my $annot_ac;
    if ($name =~ m/tRN/i){                        
     $annot_ac    = new PirObject::AnnotPair (
                         type      => "AC", 
                         genename  => "!anticodon!",
                         startpos  => $anticodon_start,
                         endpos    => $anticodon_stop
                         );
    }
    return($annot,$annot_ac);
}

sub ScreenOutput {
    my ($mail_summary,$screen_summary) = @_;
    
    my $filename = basename($DATAFILE);
    my $mail_content = "$TMP_DIR/$filename.mail" if $MAIL_ADR;
    open(MAIL, ">$mail_content") or die ("Could not open $mail_content file!\n") if $MAIL_ADR;
    print MAIL $mail_summary if $MAIL_ADR;
    close(MAIL) if $MAIL_ADR;
    
    print $screen_summary;
}

sub ListOfEmptySeq {
    my ($Ret_Rseqs,$Rseqs) = @_;
    
    my $NoSol = new IO::File ">$TMP_DIR/NoSolution"
        or die "Can't write to file '$TMP_DIR/NoSolution': $!\n";

    foreach my $Seq_name ( keys %$Ret_Rseqs ) {
        delete $Rseqs->{$Seq_name};
    }
    foreach my $Seq_name ( keys %$Rseqs ) {
        print $NoSol "$Seq_name\n";
    }
    
    $NoSol->close();
    
    system("cp","$TMP_DIR/NoSolution","./NoSolution") if !$MAIL_ADR;
    print "\nList of sequences without solution in file: NoSolution\n" if !$MAIL_ADR;
}

sub sendMail {
    my $filename = basename($DATAFILE);
    
	my $subject   = "RNAweasel Result for $MODELNAME on $filename";
    my $mail_file = "/services/WWW/cgi-bin/RNAweasel/mail_core";
    die "File for mail core doesn't exist" if !(-f "$mail_file");
    my $log_file  = "$TMP_DIR/$filename.log.tmp";
	my $mailErr   = "$TMP_DIR/mailErr";
	my $mailOut   = "$TMP_DIR/mailOut";
	
    my $cmd = "perl /services/WWW/cgi-bin/RNAweasel/bin/sendmail.pl -f \'rnaweasel\@gmail.com\' -t \'$MAIL_ADR\' -s \'$subject\' -a \'$mail_file , $log_file\'";
	print STDERR $cmd if $DEBUG;
	my $ret = system("$cmd 2> $mailErr");
	
	if (($ret >> 8) > 1) {
		print STDERR "There was an error sending mail.\n";
		print STDERR "Content of STDERR output:\n";
		system("cat",$mailErr);
	}
}

sub CopyResults {
    # Copy results to user's selected output files
    my ($aliFile,$logFile,$csmFile,$xmlFile,$apcFile) = @_;
    
    $REPORTFILE = "${DATAFILE}_${LIST_OF_SEARCHED}.log" if $LOGOUTFILE_NOTDEF;
    
    if ($ALIGNEDOUTFILE) {
        my $infh  = new IO::File "<$aliFile"
            or die "Can't read back aligned output file '$aliFile': $!\n";
        my $outfh = &PrettyOutputStream("ALIGNED", $ALIGNEDOUTFILE);
        &CopyStream($infh,$outfh);
    }
    
    if ($REPORTFILE) {
        my $infh  = new IO::File "<$logFile"
            or die "Can't read back report output file '$logFile': $!\n";
        my $outfh = &PrettyOutputStream("REPORT", $REPORTFILE);
        &CopyStream($infh,$outfh);
    }
    
    if ($XMLOUTFILE) {
        my $infh  = new IO::File "<$xmlFile"
            or die "Can't read back xml output file '$xmlFile': $!\n";
        my $outfh = &PrettyOutputStream("XML", $XMLOUTFILE);
        &CopyStream($infh,$outfh);
    }

    if ($CUSTOMOUTFILE) {
        my $infh  = new IO::File "<$csmFile"
            or die "Can't read back report output file '$csmFile': $!\n";
        my $outfh = &PrettyOutputStream("CUSTOM", $CUSTOMOUTFILE);
        &CopyStream($infh,$outfh);
    }
    
    if ($APCOUTFILE) {
        my $infh  = new IO::File "<$apcFile"
            or die "Can't read back report output file '$apcFile': $!\n";
        my $outfh = &PrettyOutputStream("APC", $APCOUTFILE);
        &CopyStream($infh,$outfh);
    }
}

sub PrettyOutputStream { # open outfh; prints pretty message; supports append mode.
    my $name    = shift || "";
    my $outfile = shift;  # with or without '>' or '>>'

    my $mode = ">";  # overwrite is default
    $mode = $1 if $outfile =~ s/^(>+)//; # remove all >
    $mode = length($mode) >= 2 ? ">>" : ">"; # sanitize

    my $prettyoutfile = $outfile;
    $prettyoutfile = "STDOUT" if $prettyoutfile eq '-';

    my $oper     = $mode eq ">>" ? "append"    : "save";
    my $oper_ing = $mode eq ">>" ? "Appending" : "Saving";
    print STDERR "$oper_ing $name output to '$prettyoutfile'...\n";

    my $outfh = new IO::File "$mode$outfile"
        or die "Can't $oper to destination '$outfile': $!\n";

    $outfh;
}

sub CopyStream { # just read write read write etc
    my $infh    = shift;
    my $outfh   = shift;

    while (my $line = <$infh>) {
        print $outfh $line;
    }

    $outfh->close();
    $infh->close();
}

# Check if the file in argument exist
sub checkFile {
	my $File = shift(@_); #file name
    die "File $File does not exist\n"
	    if (!-e $File );
}
